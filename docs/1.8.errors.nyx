---

Failing: exceptions and return values
=====================================

There are two methods of failing in Nyx. There are Errors and Exceptions. These behave slightly differently from
other languages in that: Exceptions can be thrown but not caught, and Errors are not 'thrown'
they are simply returned. This works because, in Nyx, it is a compiler error to call a function
that without either: 
    a) consuming the result in some way, e.g. `println(returnSomeData())`
    b) ignoring the result by passing it to the ignore function, e.g. `ignore(returnSomeData())`
    c) ignoring the result by assigning it to the wildcard variable '_', e.g. `_ = returnSomeData()`

---

--  For cases that are well-known to possibly fail or have no value to return, you should instead return an `Error` instance
def getCustomer
  : CustomerId -> #some(Customer) | #err(#notFound | #databaseUnreachable)
  = { id -> ... }

--  Note that, due to the Distributivity law detailed above, it doesn't matter whether you write
--  `Error(#notFound) | Error(#databaseUnreachable)` or `Error(#notFound | #databaseUnreachable)`

--  You can then filter out the error cases manually (an `Ok` active pattern is in the standard library that filters out all `Error` cases):
match getCustomer(someId)
  | #some(c) -> "We found the customer"
  | #err(#notFound) -> "A customer with that ID was not found"
  | #err(#databaseUnreachable) -> "We couldn't reach the database"
  \println

--  Or make use of the `except` builder, provided in the standard library, which has a custom keyword `try` for the `bind` construct.
--  This allows us to use what feels like traditional exception handling where errors returned by an expression preceded by a `try` 
--  are filtered out of the result expression and bubbled up to the `except` builder

def getCustomer
  : CustomerId -> #some(Customer) | #customerNotFound
  = { id -> ... }

def getLatestOrder
  : Customer -> Result(Order, #no_orders)
  = { customer -> ... }

def result = handle {
  def customer = try getCustomer("someid")
  def latestOrder = try getLatestOrder(customer)

  return latestOrder.total
}
--  `result` has inferred type of `#some(int) | #err(#customerNotFound | #noOrders)`

---

The `except` keyword
====================

Nyx has a special keyword `except` that is very similar to `match`, but is different in that it doesn't require the
matching to be exhaustive.

For example, if a function returns `#a | #b | #c`, but only want to handle `#a` and `#b`, match will result in a compiler error:

---

def f: () -> #a | #b | #c = ...

match f()
  | #a -> ...
  | #b -> ... -- Compiler error: #c is not handled

---
`except` is a bit different, in that it doesn't require all cases to be handled. It's still type-safe, however, since 
unhandled values are _returned_ as a value. This is particularly useful for handling errors, where certain values can
be "stripped off" and handled individually, with all others being returned, as you can see in the following:

---

def g = {
  def f : () -> #some(int) | #err(#notFound) = ...
  def result = f() except #err(#notFound) -> return 

  -- result is has type `int`
  ...
}

---
In this way, `except` works exactly the same way as `match` with an implicit `| x -> x` at the end of the block.

---