# Syntax

Nanyx uses clean, minimal syntax with significant indentation. Most expressions are composable, and the language prioritizes readability over brevity.

## Comments

```nyx
-- This is a single-line comment

--- 
This is a 
multi-line comment
---
```

## Value Definitions

Values are defined with the `def` keyword:

```nyx
def pi = 3.14159
def greeting = "Hello"
def count = 42
def isActive = true
```

## Function Literals

Functions are defined using braces with an arrow syntax:

```nyx
-- Simple function
{ x -> x + 1 }

-- Multi-parameter (takes a record)
{ x, y -> x + y }

-- No parameters
{ println("Hello") }
```

## Shorthand Lambdas

Nanyx supports concise syntax for common lambda patterns:

```nyx
numbers \map { * 2 }        -- multiply by 2
users \filter { .age > 18 } -- access property
items \map { > 10 }         -- comparison
```

## Pipelines

The `\` operator passes the result of one expression as the first argument to the next:

```nyx
-- Simple pipeline
value \transform \normalize

-- With additional arguments
data \process(config, options) \validate

-- Multi-line pipelines
"hello world"
  \split(" ")
  \map { .toUpperCase() }
  \join("-")
```

## Records and Tuples

Records are created with named fields in parentheses:

```nyx
-- Record creation
def user = (
  name = "Alice"
  age = 30
  email = "alice@example.com"
)

-- Record access
def userName = user.name

-- Record update (creates new record)
def olderUser = user with age = 31

-- Tuples (records with numbered fields)
def point = (10, 20)
def (x, y) = point  -- destructuring
```

## Tags

Tags represent variants in a tag union, starting with `#`:

```nyx
def status = #ok(42)
def error = #error("Something went wrong")
def flag = #enabled
```

## Type Annotations

Types can be annotated for clarity:

```nyx
-- Value with type
def count: int = 42

-- Function with type signature
def add: (int, int) -> int = { x, y -> x + y }

-- Type alias
type UserId = int
type Email = string
```

## Blocks and Expressions

Everything in Nanyx is an expression that returns a value:

```nyx
-- Block expression (returns last value)
def result = 
  def x = 10
  def y = 20
  x + y  -- returns 30


-- If expression
def sign = if x > 0 -> "positive" else -> "non-positive"

-- Match expression
def describe = match value
  | #some(x) -> "Got {x}"
  | #none -> "Nothing"
```

## Indentation

Nanyx uses significant indentation for blocks:

```nyx
def process = { data ->
  def cleaned = data \clean
  def validated = cleaned \validate
  
  match validated
    | #ok(result) ->
      result \transform \save
    | #error(msg) ->
      dbg(msg)
      msg \logError
}
```
