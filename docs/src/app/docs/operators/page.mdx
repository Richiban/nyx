# Operators

Nyx provides a set of operators for common operations. Operators are essentially functions with special syntax.

## Arithmetic Operators

Basic mathematical operations:

```nyx
def sum = 5 + 3        -- 8
def difference = 10 - 4  -- 6
def product = 6 * 7     -- 42
def quotient = 20 / 4   -- 5
def remainder = 17 % 5  -- 2
```

## Comparison Operators

Compare values:

```nyx
def equal = 5 == 5          -- true
def notEqual = 5 != 3       -- true
def lessThan = 3 < 5        -- true
def lessOrEqual = 5 <= 5    -- true
def greaterThan = 10 > 5    -- true
def greaterOrEqual = 7 >= 7 -- true
```

## Logical Operators

Boolean logic:

```nyx
def and = true && false  -- false
def or = true || false   -- true
def not = !true          -- false
```

## Pipeline Operator

The most distinctive operator in Nyx:

```nyx
-- Forward pipeline
data \process \validate \save

-- Equivalent to: save(validate(process(data)))
```

## String Operators

String concatenation:

```nyx
def greeting = "Hello, " + "World!"  -- "Hello, World!"
def message = "Count: " + count.toString()
```

## Operators as Functions

Operators are just functions and can be used as such:

```nyx
-- Partial application
def double = { * 2 }
def increment = { + 1 }

-- In higher-order functions
def sum = [1, 2, 3] \fold(0, +)
def product = [1, 2, 3] \fold(1, *)

-- Comparison in filter
def positives = numbers \filter { > 0 }
```

## Operator Precedence

From highest to lowest:

1. Function application: `f(x)`
2. Unary operators: `!`, `-`
3. Multiplication/Division: `*`, `/`, `%`
4. Addition/Subtraction: `+`, `-`
5. Comparison: `<`, `<=`, `>`, `>=`
6. Equality: `==`, `!=`
7. Logical AND: `&&`
8. Logical OR: `||`
9. Pipeline: `\`

Use parentheses for clarity:

```nyx
def result = (a + b) * c
def valid = (x > 0) && (x < 100)
```

## Custom Operators

Nyx doesn't support defining custom operators, keeping the language simple and predictable. Use named functions instead:

```nyx
-- Instead of custom operator
def compose: ((b -> c), (a -> b)) -> (a -> c) = { f, g ->
  { x -> f(g(x)) }
}

-- Use it like a function
def addOneThenDouble = compose(double, addOne)
```

## Pattern Matching with Operators

Use operators in patterns:

```nyx
def classify: int -> string = { x ->
  match x
    | < 0 -> "negative"
    | == 0 -> "zero"
    | > 0 && < 10 -> "small positive"
    | >= 10 -> "large positive"
}
```

## Operator Sections

Partially applied operators:

```nyx
-- Right section
def double = { * 2 }      -- multiply by 2
def halve = { / 2 }       -- divide by 2

-- Left section (less common)
def subtractFrom10 = { 10 - }
```

## Short-Circuit Evaluation

Logical operators short-circuit:

```nyx
-- Second expression not evaluated if first is false
def result = false && expensiveComputation()

-- Second expression not evaluated if first is true  
def result = true || expensiveComputation()
```

## Operator Examples

### Mathematical Operations

```nyx
def distance: (Point, Point) -> float = { p1, p2 ->
  def dx = p2.x - p1.x
  def dy = p2.y - p1.y
  sqrt(dx * dx + dy * dy)
}
```

### Filtering

```nyx
def adults = users \filter { .age >= 18 }
def teens = users \filter { .age >= 13 && .age < 20 }
def seniors = users \filter { .age >= 65 }
```

### Validation

```nyx
def isValidAge: int -> bool = { age ->
  age >= 0 && age <= 150
}

def isValidEmail: string -> bool = { email ->
  email.length > 0 && email \contains("@")
}
```

### Chaining Comparisons

```nyx
def inRange: (int, int, int) -> bool = { value, min, max ->
  value >= min && value <= max
}

def valid = inRange(age, 0, 150)
```

## Operator Naming Conventions

Operators in Nyx follow these conventions:

- Arithmetic: `+`, `-`, `*`, `/`, `%`
- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`
- Logical: `&&`, `||`, `!`
- Pipeline: `\`
- Property access: `.`
- Function application: juxtaposition (e.g., `f(x)`)

This keeps the operator set small and predictable, avoiding the complexity of languages with many custom operators.
