---
  Operators
  =========

  Operators in Nyx are ordinary functions with special syntax. Because operators are values, you 
  can call them infix, postfix, prefix, or pass them around just like any other function. 
  Unlike many other languages, operators in Nyx *must* be double-spaced at the point of use.

---
  # Defining operators

  Some languages have a mapping of operators <-> function names, where `a || b` 'desugars' to 
  `Bool.or(a, b)`. That's not how Nyx works; we feel that this table can be difficult for users
  to keep in their heads over a long period of time ("Wait, was '%' called 'mod()' or 'modulo()'? 
  Or maybe it was 'percent()'? Actually, I think this is technically remainder instead of modulo 
  so maybe it was 'rem()'?").

  Instead, Nyx relies on the fact that we can write definitions with names that would normally be
  illegal using `` syntax. For example, we can put spaces in a definition name: 

def `my value` = ??? 

---
  We use this to write an operator in Nyx:

def `+++`: string, string -> string = { a, b -> ??? }

If a definition is a valid operator name then Nyx will allow you to use it as an operator:

def r = "one" +++ "two"

---
  Nyx is a bit unusual in that an operator can have any number of arguments (well, except 
  none at all!). An operator with one argument is a unary operator and everything else is a binary
  operator. If an operator function has three or more arguments then the same rule as piping
  is followed, i.e. that all remaining arguments are supplied in a record.

def `+?` = { a, b, c -> ??? }

def r = a +? (b, c)

---
  # Arithmetic

  The core arithmetic operators are `+`, `-`, `*`, `/`, `%`, and `**` (power). They work on any
  type that implements the corresponding members through contexts such as `Number(Î±)` or custom typeclasses. This means you can overload the
  operators by providing the right context in scope.

def total = 2 + 3 * 4

context VectorOps = (
  `+`: Vector, Vector -> Vector
)

def vectorOps: VectorOps = (
  `+` = { a, b -> a + b }
)

use vectorOps in a + b

---
  # Comparison

  `==`, `!=`, `<`, `<=`, `>`, and `>=` are also functions. They live in the `Comparable`/`Equatable` family of contexts
  and short-circuit just like their functional equivalents. Because they are values you can pass them to higher-order
  functions:

def isEven = { \mod 2 == 0 }

numbers \filter(isEven)

---
  # Logical

  Logical operators include `and`, `or`, and `not`. They are aliases for short-circuiting
  functions. Like all operators, you can use them as values when you need to compose predicates.

def isValid = { .length > 0 } and { .trim() != "" }

---
  # Pipe and Composition

  Nyx provides `\` for left-to-right piping, essential for building fluent pipelines without 
  deeply nested calls.

def result = data
  \filter { .isActive }
  \map { .name }
  \sort

---
  Function composition uses the `>>` and `<<` operators (forward and backward composition respectively):

def normalize = trim >> toLowerCase

---
  # Assignment and Mutation

  `=` defines immutable bindings. `mut` introduces mutable storage, and you update it with `set` or augmented assignment
  operators such as `+=` when the relevant context supplies them.

mut count = 0
set count = count + 1

---
  # Custom Operators

  Because operators are functions, you can define new ones by naming a function with the desired operator token. When
  necessary, mark them with backticks to avoid conflicts with identifier rules.

def `++` = { a, b -> combine(a, b) }

values \reduce(`++`)

---
  Operator precedence is fixed; custom operators follow the precedence of their base token.
  Explicit parentheses are the disambiguation tool when precedence is unclear.

---
  # Overload Resolution

  Operator behavior is driven by the contexts available at the callsite. If multiple contexts provide the same operator,
  Nyx selects the most specific in scope. When no implementation is available the compiler warns but allows execution,
  falling back to runtime resolution.
