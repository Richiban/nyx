---
Tags
====

Tags are a foundational, and rather unusual, feature of Nanyx. Tags are a special type of 
literal; a tag's name is also its value, which is also its type.

Tags are similar to symbols in Ruby or atoms in Erlang. They also have some similarities
with Typescript's string literal types, although tags are not strings.

---

--  Tags can be used as values:
def x = #myTag

--  And also types:
def y: #mySecondTag = #mySecondTag
  
--  Tags are not particularly useful on their own; they are really designed
--  to be used in tag unions. One such use case is for passing flags to functions:
def openFile
  : string, (#read | #readwrite) ->  
  = { fileName, mode -> 
    ...
  }

openFile("file.txt", #readwrite)

---
Tags are implemented with a lookup table, unique to each running application. As the application
loads other libraries the tags from those libraries are added to the lookup table. This means that
tags with the same compile-time name will always successfully compare by value, even though the name
is not present at runtime.

---

-- Tags can be used in type unions to emulate enums:

type Color = #red | #green | #blue

-- Tags can carry values to effectively implement discriminated unions:

type Color = 
    | #red
    | #green
    | #blue
    | #custom(string)


-- Since tag unions are _structural_, it's possible to write polymorphic functions that might specify
-- that a particular type union has at least one or more particular tags in it, but is flexible on any
-- other members. For example, the Option.map function in the standard library is such a function.

-- Here we see that Option.map accepts a value of any tag union as long as that union includes `#some(α)`
    
def Option.map
  : (#some(α) | rest), (α -> β) -> (#some(β) | rest)
  = { | #some(a), f -> #some(f(a))
      | other, _ -> other }

-- In the pattern match we first see if the value is `#some(a)`; if it is then we map the internal value.
-- Crucially, any other value is simply returned as-is. This has the effect of preserving the names of
-- any non-success cases in a union, for example:

def x : (#some(string) | #notFound) = ...
def y : (#some(int) | #divideByZero) = ...

x \Option.map { .length } -- (#some(int) | #notFound)
y \Option.map { \Math.abs } -- (#some(int) | #divideByZero)