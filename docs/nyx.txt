''	------------------------- 
      ---------- Nyx ---------- 
      ------------------------- 




''  ------- Comments -------

    Comments are started with two single quotes together `''`.
    To make a comment span multiple lines you just intent the subsequent lines more than the quotes that started the comment.

    This means that there's no need for a separate block comment construct; anything indented further 
    than the `''` is considered part of the comment



''	------- Variables ------- 
      Variables are defined using the 'def' keyword.
def name = "Fred"

''	Variables are, by default, immutable. If you need a value you can mutate you
   can create a reference cell using the function `ref`
def age = ref 21


''  Mutable variables are specified with the `mut` keyword instead of `def`


'' 	------- Literals ------- 
      There are a few types of literal in Nyx. Some you will be used to, such as ints, strings and
      bits.
def age = 21		''	int
def name = "Fred"	''	string
def factor = 1.5	''	double

'' Tags
def mode :: #read | #readwrite = #readwrite '' 

''	Ranges
def range = 1..5
def fromBeginningTo5 = ..5
def from4ToEnd = 4..

def arraySlice = data(1..100)
def anotherSlice = data(1..)

def first5Letters = str.subString ..4

''	Tuples

''	A comma joins two or more values together into a tuple. each member of the tuple can be
      of any type
def things = ("John", "Alexander", 5, Uri())

''	Because Nyx supports union types a tuple can be enumerated. In the above example the
      tuple "things" is of type (string, string, int, Uri), and can be used as a Sequence
    of the following type: Sequence(string|int|Uri).

for things as thing:
    thing
    \	case s :: string:  	"We have a string: {s}"
        case i :: int:  	"We have an integer: {i}"
        case uri :: Uri:  	"We have a uri: {uri}"
    \ print

''	Other literals might not be found in other languages, such as object literals.
def coordinates = ( x = 1, y = 2 )

''	Target-typed collection literals, defaults to List
def numbers = [1, 2, 3]

''	Table literals
    This is shorthand for writing a list of objects that have the same structure but
    differing contents. Example:

def namesAndAges =
    [| name 		| age	|
     | "Felix" 		| 22	|
     | "Taylor" 	| 30	|
     | "Peter" 		| 28	|
     | "Sean" 		| 45	|]

''	This is equivalent to:
def namesAndAges = [
    ( name = "Felix", 	age = 22 ),
    ( name = "Taylor", 	age = 30 ),
    ( name = "Peter", 	age = 28 ),
    ( name = "Sean", 	age = 45 )
]



''	------- Tags ------- 
    Tags in Nyx are a special type of literal. A tag's name is also its value, which is also its type.
    If you know Typescript then tags are similar to Typescript's string literal types
    If you know Erlang then tags are similar to atoms except, of course, they're strongly typed

''  Tags can be used as values:
def x = #my_tag

''  And also types:
def y :: Option(#my_second_tag) = #my_second_tag

''  Tags are especially useful when combined with union types, such as for passing flags to functions:
def openFile(fileName :: string, mode :: #read | #readwrite): 
    ...


''  Question: Should these be called "symbols" instead? And written `$my_symbol`?



''	------- Functions and maps ------- 
    Since Nyx contains many concepts from functional programming, it is useful to be able to easily
    write a function literal.

def print1 = { print "1" }
''   which can also be written as:
def print1(): print "1"

items.iter print

''	<\ is the backwards pipe operator, also known as the apply operator. Same as `<|` in F# or `$` in Haskell
def names = data.map <\ { item: item.name }

Web.makeRequest (
    url = "http://some.api.com/"
    success (error?, response?, data?) =
        print "There was an error: "error". The response was "data )

''	This sumList example defines a function making use of a match expression. \ is the pipe operator in Nyx
rec sumList(xs): xs
    \ case []             : 0
      case [head, ...tail]: head + sumList tail


''	Note that, as in the example above, if the entire function consists of a single match expression then
    you can merge the function definition and case statements together, dropping the need to name an argument
rec sumList case []             : 0
            case [head, ...tail]: head + sumList tail

''	Simple member access can be turned into a function as such:
def namesAndAges =
    [| name 		| age	|
     | "Felix" 		| 22	|
     | "Taylor" 	| 30	|
     | "Peter" 		| 28	|
     | "Sean" 		| 45	|]

def ages = namesAndAges \ map { age }

''	If you want a parameter to be optional, prefix its name with a ?
    Note that any optional parameters will automatically be wrapped in an option type.
    The compiler handles optional parameters by inserting None at the callsite.

def printMessage(?message): 		''	"message" is of type `string?` (short for `Option(string)`)
    message
    \ case #none     :  "You didn't say anything"
      case #some, msg:  "You said: " msg
    \ println

''	You can also make parameters optional by giving a default value. In this case the type of
     the parameter is still `Option(t)` as far as any callers are concerned but the type is
     automatically unwrapped for you inside the method. If None was supplied at the callsite
     then it will be substituted for the default value you gave in the method declaration
printResults(left = "left", middle, right = "right"):
    print "{left}, {middle}, {right}"

printResults("1", "2", "3")	''	legal
printResults("1", "3")			''	legal
printResults"1"				''	Not legal
printResults()					''	Not legal
printResults(middle = "2")		''	Legal. Instead of supplying each argument individually you can supply an
                                ''	object with the same shape as the list of parameters. More examples:

''	Function arguments can be thought of as a single object with a number of properties.
type Person = (name :: string, age :: string)

def john = Person("John", 28)

def f(name :: string, age :: int): "{name} is {age} years old."

f(john.name, john.age)	''	Conventional method call
f(john)					''	This is legal as the object 'john' has the right shape for the collection of
                        ''	parameters for the function f.


''	An incomplete expression (including operators, indexers and member calls) can be wrapped in
      parentheses to turn it into a function.
double = (* 2)
double 5 		''	=> 10

def names = "John", "Adam", "Alexander"
def backwards_names = names.map { reverse() }	''	=> ["nhoJ", "madA", "rednaxelA"]
def first_letters = names.map { _[0] }			''	=> ["J", "A", "A"]
def long_names = names.filter { length > 5 } 	''	=> ["Alexander"]


'' Functions can be composed. Think of it as pre-preparing a pipe
def firstThree(str :: string): str.substring(0, 3)
def reverse(str :: string): str.reverse()

def lastThree = reverse >> firstThree >> reverse

'' The following two statements are equivalent
"Hello" \ (reverse >> firstThree >> reverse)	''	=> "llo"
"Hello" \ reverse \ firstThree \ reverse		''	=> "llo"


''	Functions have the signature `a -> b`, where `a` and `b` are the types
     of the function's input and output, respectively.
     All functions in Nyx take *one* value as input and product one value as output.
     This doesn't sound very useful until you consider that tuples allow you to
     pass multiple values as one and unit allows you to return no values.

     Functions are not the only objects that have this signature `a -> b`, however.
     The type `a -> b` is called a `map`, and there are a number of maps in Nyx, not
     just functions. Dictionaries are an example, as are strings. Any object of type
     `map` is considered 'applicable', and can be 'called' just like a function

spec int -> int
def f(x): x * 2

f(2)					'' 4

spec string -> string
def dict = map { "Hello" -> "Bonjour"; "Goodbye" -> "Au revoir" }

dict("Hello")		'' "Bonjour"

def greeting = "Hello, "

greeting("John")		'' "Hello, John"

''  Note: there is no overloading in Nyx. With optional/named parameters and union types 
    there is so little need for overloading that it's not worth the considerable complication to the compiler



''  ------- Strings -------

    Strings are one of the fundamental building blocks of a program. In Nyx there are two
    main types you will be using: `nyx/String` and `nyx/StringBuffer`.

    Note: `nyx/String`, like `nyx/Int32` is so common that it has a keyword for it built 
    into the language. This allows you to use simply `string` instead, with no need to 
    explicitly import `nyx`.


''
    ------- If-statements and branching -------

'' If-statements

if cond:
    some_code()
else:
    some_other_code()


''  If-statements can have many branches, obviating the need for `else if` or `elif` chains
if cond1:
        some_code()
   cond2: 
        some_other_code()
   else:
        yet_more_code()

''	A pattern is something that can be assigned to (in a variable
    assignment or parameter declaration) or tested against (in a
    match expression). Here are some examples:
def names = ["Joey", "Elizabeth", "Samantha"]

''	Array destructuring
    Note that, since this pattern may fail, you must use the `is` keyword instead of `def`
if names is [first, second, third, ...]:
    println(first) 		''	=> "Joey"
    println(second) 	''	=> "Elizabeth"
    println(third) 		''	=> "Samantha"

''	Object destructuring by position
def john = Person("John", 28)
def name, age = john
name							''	=> "John"
age								''	=> 28

''	Object destructuring by member name
def (name = name2, age = age2) = john
name2							''	=> "John"
age2							''	=> 28


''	Splats can be used in list destructuring. Patterns can be used when declaring
    parameters to a function
def results = ["Jamie", "Alex", "Robin", "Sam", "Jo", "Ashley"]
def printResults [first-place, second-place, third-place, ...rest] =
    firstPlace 					''	=> "Jamie"
    secondPlace 				''	=> "Alex"
    thirdPlace 					''	=> "Robin"
    rest 						''	=> ["Sam", "Jo", "Ashley"]

''	Destructuring can be arbitrarily nested. Labels can be used (as <identifier>)
     when destructuring so that you still have
    a variable holding the value that has been destructured.
    Especially useful with nested destructuring:
[[x, ...xs] as list1, [y, ...ys] as list2] = [ [1,2,3], [4,5,6] ]
x     	#=> 1
xs    	#=> [2,3]
list1 	#=> [1,2,3]
y     	#=> 4
ys    	#=> [5,6]
list2 	#=> [4,5,6]


''	Object and array destructuring can be combined. Also, splats can be used
    alone to ignore the results of it.
def text = "Hello world"
def (length = length, letters = [firstLetter, ..., lastLetter]) = text

'' Pattern matching is done using a series of `case` keywords. Unlike many other languages
   there isn't exactly a `match` statement; instead a series of `case` keywords form a 
   pattern matching function which can be used as a function or piped to immediately.
   When piping to a function immediately the compile will erase the creation of a function
   object for performance

spec int -> string
def classifyNumber = { 
    case 0    : "zero"
    case 1..10: "small"
    case > 10 : "really big!"
    else      : "unknown"
}

def oddOrEven(n):
    n % 2
    \ case 0: "even"
      else  : "odd"

def fizzbuzz(range :: seq(int)):
    range
    \ map { i:
        i % 3, i % 5
        \ case 0, 0: "fizzbuzz"
          case 0, _: "fizz"
          case _, 0: "buzz"
          else: string(i)
    }


'' ------- Loops and queries ------- 

''	A simple n-times loop
for 1..5: print "Hello"

for 1..5 as i: print "Hello times {i}"

data = [1, 2, 3]


''	Straightforward 'foreach' loop
for data as item: println(item)


''  Behind the scenes for-loops are compiled into function calls. The variables that
    can be declared are defined by the function being called. For example: the type
    <list> has a method "for" that takes a function that takes *two* parameters.
    This means that the following are possible:

''	Foreach loop with index variable as well using zip-enumeration
def data = ["one", "two", "three"]
for data, 0.. as item, i: print "Item number {i} is {item}"

''	The above code is exactly equivalent to the following:
data | iteri { item, i:  print "Item number {i} is {item}" }

''	Looping over a dictionary and getting both the key and value on each iteration:
def data = ["one", "uno"; "two", "dos"; "three", "tres"]
for dict as key, value: print "{key} => {value}"

''	The above code is exactly equivalent to the following:
data \ iter { key, value:  print "{key} => {value}" }

''	If you want to ignore one of the variables available to you in the loop you can
    either: simply omit the variable (if the variable you're omitting is at the end
    of the list of available variables) or use the wildcard '_' in its place. E.g.
for dict as _, value: 
    print "I only care about {value} in this dictionary"

''	Note that, as with almost any statement in Nyx, a for loop is also an expression.
    This means that is can be used on the RHS of an assignment by 'selecting' a value.
    This brings us on to:

''	Querying

type Person = (name :: string, age :: int)
    def sayHello(): "Hello, my name is {name} and I am {age}"

''  Constructors can be referenced as if they're a method
def people = ["John", "Adam", "Xavier"] \ select(Person)

def numSelected =
    for checkboxes as checkbox
    where checkbox.isSelected
    \ count


def totalSpendForCustomer =
    for orders as order
    where order.customerId == 5
    yield order.total
    \ sum

'' You can do complicated queries such as joins, and even combine them
'' with 'do' to make superloops
for customers as customer
join order from orders on order.customerId == customer.customerId
where order.total > 100 and customer.age > 18
distinct order.customerId, customer.name
do:
    console?.log "{customer.name} (id: {order.id}) is over 18 and has at least 1 order over $100"


'' -------	Types: Type expressions ------- 
    The powerful type inference means that type annotation are rarely
    necessary.

    Some basic types:

    Anything (alias: any. The top type for Nyx, or the set of all possible values. All types can be assigned to 'any')
    Null (alias: (). The Unit type for Nyx. Has only one value: '()')
    Undefined (alias: {}. The bottom type for Nyx, or the set of no values. 'Undefined' can be assigned to all types.)

    A function can take an argument of type 'any'. This allows any object to be passed in.

def f(a :: any) = string a

''	A function with a type of 'undefined' will never return. Either it will loop forever or will always throw.

def f() :: undefined = throw NotImplementedException

''  Set Operations

      The type system in Nyx is based on set theory. When defining a value such as 'x :: string'
      that can read as 'value x which is a member of the set of all strings'. This allows us to perform operations
      on the type system to create new types or type contraints using the type syntax. The available operations are:

def x :: string | int = ...	'' (|) is a set union. In this case 'x' is a member of the set which is a union of 
                            '' strings and ints, meaning that in this case x is a string or an int  

def x :: (string, int) = ...	'' (,) gives the cartesian product of two (or more) sets, i.e. a tuple.

def x :: A & B = ...			'' (&) gives the intersection between two sets. So x is of type A *and* type B.

''   There are some rules around set operations such as:
''   Commutativity:

A | B === B | A

''	Associativity:

(A | B) | C === A | (B | C)

''	Reduction:

A | A == A  

''  Distributivity:

A | (B & C) == (A | B) & (A | C)

(A, B) | (A, C) == (A, B | C)

''	The Unit type is so-called because it has exactly one member and can be thought of as '1' when it comes to set theory. 
''	For example, for any value a => a * 1 === a. In the same way, for any type A, A * () === A.

''	This theory extends to the idea of the Bottom type '{}' (the empty set) or 'undefined'. It can be thought of as '0' in set theory.
''	For any value a => a * 0 === 0. In the same way, for any type A => A * {} === {}

''   The empty list `[]` can be thought of as `List(undefined)` or `List({})`. This way the function `.head` on [] has type `undefined`.

def x = head([]) '' x :: undefined

''	The above code will always fail and the compiler will highlight the fact that any code after this is unreachable. 


''	-------	Types: Tuples -------
''	Tuples are a way of grouping values together. They are immutable (by default) and can contain any type of value. 
''  Each tuple is optionally named; if you do not supply a name then the field is said to be 'positional' and its name
''  will be the value of the index of the field. For example, the following tuple:

type MyTuple = (string, data :: string, int)

''  Is equivalent to:
type MyTuple = (
    0 :: string
    data :: string
    2 :: int
)


''	In Nyx, tuple types can be thought of as abstract types, or interfaces. When thinking of interfaces think
''	of structural interfaces, meaning that they don't need to be explicitly implemented. Example below:

type Named = (name :: string)

type Person = (name :: string)

def john :: Named = Person("John")	''	This is legal even though Person doesn't
                                    ''	explicitly derive from Named

type Named = ( name :: string )
    def sayHello(): "Hello, my name is {name}" 

''	Types can be extended via the mechanism of type intersections:
type Person = Named & (age :: int)

type Pet = (name :: string)

def sayName(named :: Named): "Your name is {named.name}"

sayName(Person "John")	''	Valid, as Person explicitly implements INamed

sayName(Pet "Rex") 		''	Also valid, as Pet has the right 'shape'
                            ''	for Named, even though it doesn't explicitly
                            ''	implement it

''	Tuples can also have optional members.

type Person1 = (name :: string; petsName? :: string)

''   This could also be written as a type union, as seen below:

type Person2 = 
    | (name :: string, petsName = #none)
    | (name :: string, petsName :: string)

''  Note that, even though the type of 'petsName' has been declared as 'string', it ends up being `string?`

''	Enums can be modelled through tag unions. Example:

type Colour = #red | #green | #blue

''  Discriminated unions can be modelled through unions of tuples, where a tag in the first position is used 
    as the discriminator. Example:

type Shape = 
    | (#circle, radius :: number)
    | (#rectangle, width :: number, height :: number)

''  You can then pattern match on the tag to extract the values:

spec Shape -> number
def area case (#circle, radius)          : Math.pi * radius ** 2
         case (#rectangle, width, height): width * height

type ContactInfo = 
    | #none
    | (#telephone, string)
    | (#email, string)
    | (#email_and_telephone, email :: string, telephone :: string)

'' Usage: 

def sendMessage(contactInfo :: ContactInfo):
    contactInfo
    \ case #none:
        () '' Do nothing
      case #telephone, telephone:
        sendSMS(telephone)
      case #email, email:
        sendEmail(email)
      case #email_and_telephone, email, telephone:
        sendEmail(email)
        sendSMS(telephone)

''	There is no equivalent of 'void' from other languages; it is convention to use the tag '#none' instead.
''  Note: you may ask why we don't use the empty tuple () instead of #none. The reason is that, since tuples are
''  structurally typed, () is actually the top type of all tuples.

spec string -> #none
def writeToConsole(message):
    ...

''	Tuple types can be defined inline at the point of their use.
def calculateDistance (point :: (x :: int, y :: int)):
    Math.sqrt point.x ^ 2 + point.y ^ 2


type A = ( a :: string )
type B = ( b :: string )

def obj :: A & B = ( a = "a", b = "b" )


''  -------	Specs -------
''  Specs are a syntax for writing the type of a definition separately. They are optional but are recommended for exported functions

''  Types can be specified inline in Nyx with the `::` syntax, for example:

def x :: string = "Hello world"

''  For some definitions, such as functions or definitions involving generics or contexts, inline types annotations can quickly make 
''  the definitions long and unwieldy. Nyx allows
''  types to be written on a separate line above the definition, in a spec:

spec string
def x = "Hello world"

spec (string, CustomerId, Logger) -> Customer
def getCustomer(connectionString, customerId, logger): ...

spec string -> string
def greet(name): "Hello, {name}!"

'' Specs can also be used for generic functions or values
spec a -> a
def self(x): x 

''  Exported functions should be given a spec; you'll get a compiler warning if you don't.

    Specs can optionally specify the name of the definition they apply to. This would normally be ommitted
    on definitions (where the definition immediately follows the spec) but is required on specs present in 
    a trait where there is no definition attached

    For example:

trait MyTrait:
    spec aMethod :: (string -> string) '' Spec name required (no definition is attached)

    spec string -> string
    def anotherMethod(x): x '' Spec name can be omitted because it is attached to a definition


'' -------	Contexts -------

    Contexts are a way of controlling access to stuff.
    Contexts appear as a sort of extra parameter on a function;
    when a function specifies a context that it runs in, all the members of that context are available to it. For example:
    
spec [CurrencyConversionTable] (Pounds, Dollars) -> Dollars
def addPoundsAndDollars(p, d):
    convert(p, #dollars) '' `convert` is a function on the `CurrencyConversionTable` context

''  This is how effect control is done in Nyx

''  All console programs implicitly run in ConsoleContext, giving access to things like `print` and `readline`

def main():
    sayHello()

''  Functions can be annotated with a context. The functions on that context are now available to call within that function, and functions
''  that in turn require that context can be called
spec [ConsoleContext] () -> ()
def sayHello():
    println("Hello world!")


''  Contexts can be combined. For example, the following function requires a context that has both `ConsoleContext` and `FileSystemContext`:
spec [ConsoleContext, FileSystemContext] () -> ()
def readAndPrintFile(filename):
    def contents = file.open(filename).contents

    print(contents)



''  Contexts also allow for Haskell-style typeclasses. For example, the following context allows any type to be converted to a string:

trait Writeable(a):
    spec write :: a -> string

type Person = (name :: string, age :: int)

impl Writeable(Person):
    ''  Note that the spec is inferred from the trait and doesn't need to be written again
    def write(p): "{p.name} is {p.age} years old"


spec [Writeable(a)] a -> string
def someFunction(x):
    println(write(x)) ''  Since we're in the context of Writeable, the function `write` is in scope


''  When in a function body, in order to call another function that requires a context, you have two options (let's say you're
''  in function `f` and you want to call function `g`):
''	    a) add the context to your function's signature, therefore passing the need to create a context on to your caller
''	    b) create a context yourself, start a context block, and then call `g` within that block
''      c) import an `impl` that gives you the context that you need

type MyContext = (
    m :: string -> ()
)

def g[MyContext](): 
    m("Hello world") '' `m` is in scope from context `MyContext`


def f():
    g() ''  This will fail because `g` requires a context that `f` doesn't have

def f[MyContext](): 
    g() ''  This works because we have added the context to `f`'s signature

def f():
    def c :: MyContext = (def m(s): println(s))

    context(c):
        g() ''  This works because we have created an instance of the necessary context and started a context block

def f():
    import aModule/containingAnImplOf/MyContext ''  This works because we have imported an impl that gives us the context we need

    g()

''  -------	Failing: exceptions and return values -------

''	There are two methods of failing in Nyx. There are Errors and Exceptions. These behave slightly differently from
      other languages in that: Exceptions can be thrown but not caught, and Errors are not 'thrown'
       they are simply returned. This works because, in Nyx, it is a compiler error to call a function
      that without either: 
          a) consuming the result in some way, e.g. `println(returnSomeData())`
          b) ignoring the result by passing it to the ignore function, e.g. `ignore(returnSomeData())`
          c) ignoring the result by assigning it to the wildcard variable '_', e.g. `_ = returnSomeData ()`

''  For cases that are well-known to possibly fail or have no value to return, you should instead return an `Error` instance
spec CustomerId -> Result(Customer, #not_found | #database_unreachable)
def getCustomer(id): ...

''  Note that, due to the Distributivity law detailed above, it doesn't matter whether you write
''  `Error(#not_found) | Error(#database_unreachable)` or `Error(#not_found | #database_unreachable)`

''  You can then filter out the error cases manually:
getCustomer(someId)
\ case Ok(c): "We found the customer"
  case Error(#not_found): "A customer with that ID was not found"
  case Error(#database_unreachable): "We couldn't reach the database"
\ println

''  Or make use of the `except` builder, provided in the standard library, which has a custom keyword `try` for the `bind` construct.
    This allows us to use what feels like traditional exception handling where errors returned by an expression preceded by a `try` 
    are filtered out of the result expression and bubbled up to the `except` builder

spec CustomerId -> Result(Customer, #customer_not_found)
def getCustomer(id):   ...

spec Customer -> Result(Order, #no_orders)
def getLatestOrder(customer): ...

def result = except {
    def customer = try getCustomer("someid")
    def latestOrder = try getLatestOrder(customer)

    return latestOrder.total
}
''  `result` has inferred type of `Result(int, #customer_not_found | #no_orders)`



'' -------	Generic types ------- 

''	What happens if there are no type annotations and the compiler doesn't have any uses with which
''	to guess the type? E.g.
def f(x): x

''	This function takes in an object and then just returns it. What type is `a`? Any? No. If the compiler
''	can't infer the type of the argument it will try to make your function generic.
''	So, rewriting the above function in full:
spec a -> a
def f(x): x		''	This way the function is still strongly-typed but will work on any type

''  Note that there isn't a syntax for introducing a type parameter for a function; you just use a type variable (that
    must start with a lowercase letter) and the function will be made generic


spec Map(string, a) -> ()
def printDict(values) =
    values \ iter(println)




'' ------- Classes -------

''  Nyx doesn't have classes, but there are a number of ways in which you can simulate them. The first is to define
''  the type, and then give it a constructor function that takes in the necessary parameters and creates an instance
''  of the type. 
''  For example, the following code creates a class-like structure for a `ResourceController`:

type ResourceController = (
    get :: string -> Result(Resource, #not_found)
    post :: Resource -> #ok | Error
)
    def apply(repo :: ResourceRepository) :: ResourceController: (
        def get(id): repo.get(id) \ Option.map(toJson)
        def post(data): repo.save(data)
    )

''  Captures allow for private state, such as in the following counter class:
type Counter = (
    count :: int
    inc :: () -> ()
    dec :: () -> ()
)
    def apply() :: Counter: 
        mut count = 0
        ( def count: count
          def inc(): set count = count + 1
          def dec(): set count = count - 1 ) 



'' ------- Type narrowing -------

'' 	Nullable / optional types
''	There is no concept of `null` in nyx. If you want to represent a value that may be missing you
''	must wrap the type in something like the option union
def stringLength :: Option(int) = #none

''	Option is a type alias, and is defined as follows:
type Option(t) = (#some, t) | #none

''	The type is generic, meaning that `t` can be any type. `Option` is equal to `t | ()`, meaning that any member of
''	Note that the option type has a special shorthand syntax supported by the compiler. You can instead write:
def stringLength :: int? = #none

''	You can't use an optional string as if it were a string. E.g. This is not allowed:
def input :: string? = ""
def stringLength = input.length

''	If you want to access properties on the string object you must either:
''	1. Use a match expression
def stringLength =
    input
    \ case #none:  0
      case s   :  s.length 	'' Note that the compiler can infer that s is a string in this case, since all other 
                            '' cases have been exhausted by this point

''	2. Use an if expression. Note that in the block when the compiler knows that the string is not null,
''	the type has automatically changed from <String?> to <String>. This is called "type narrowing"
spec string? -> int
def stringLength(input):
    if input == #none: 0
    else input.length ''	In this else block the input variable has been "narrowed" to a string

''	3. Use the standard library's bang operator "!". This will cause a runntime error to be thrown if the value is 'nothing'
def stringLength = input!.length
print(input!)

''	Note that the postfix bang operator "!" is actually compiler shorthand for .force()
''	The above example could also be written as:
print <| input.force()

''	4. Use the map operator "*.". This means that if the value is null the entire expression will
''	not be evaluated, and null will be returned. Note that in this example the type of stringLength is not
''	`int`, but `int?`
def stringLength = input?.length

'' 	Note that the "?" operator is compiler shorthand for a call to the `.map` function, if it exists.
''	The above example could also be written as:
def stringLength = input.map { length }

''	Optional parameters
''	Nullable types work together with optional parameters. In the following examples the external signature
''	shows that the type of startIndex is `int?`, and the compiler will allow the function to be called without
''	supplying that parameter. However, inside the function the type of startIndex appears to be `int`
def slice(list, startIndex = 1):
    list.slice startIndex



''	------- Standard library ------- 

''  Main abstractions (traits)
Seq(t) 					    '' Equivalent to .NET's IEnumerable<T>. May or may not be infinite, may or may not be in memory
└ Collection(t) 			'' An in-memory collection of `t`s. Finite in size
  ├ List(t)					'' A collection of `t`s that supports random access by index
  ├ Series(t) 				'' A linear collection in memory. Getting an element by index requires walking through the collection
  ├ Set(t) 					'' An unordered collection of `t`s that supports fast addition and 'contains' checking
  │ └ SortedSet(t) 			'' A sorted collection of `t`s that supports fast addition and 'contains' checking
  ├ Map(k, v) 				'' A collection of `v` values stored against a key `k`. Each `k` has a single value `v`
  │ └ BiMap(a, b) 		    '' A collection of `(a, b)` value pairs that supports lookup in both directions
  └ Lookup(k, v) 			'' A collection of `v` values stored against a key `k`. Multiple values may exist for each `k`
    
''  Async collections
Stream
├ ASYNCGENERATOR(t)	
└ AsyncCollection(t) 			



Array(t) :: List(t)
            ├ Map(int, t)
            │  └ Collection((int, t))
            │     └ Source((int, t))
            └ Collection(t)
               └ Source(t)



Dictionary(key, value) :: Map(key, value)
                            └ Collection((key, value))
                                └ Sequence((key, value))


Promise(t)
├ Async(t)
├ Lazy(t)
├ Ref(t)


''	Abstractions


type Source(a) =
    ( getEnumerator :: () -> Enumerator(a) )

type Collection(a) =
    Sequence(a) & ( count :: int )

type Map(key, value) =
    Collection(a) & ( get :: key -> value )

type List(a) =
    Map(int, a) & Collection(a)


''	Implementations
type LinkedList(a) =
    () | (a, LinkedList(a))
    & Sequence(a) 
        def getEnumerator():
            seq { 
                mut current = this

                while this is (head, tail):
                    yield head
                    set current = tail
            }

type NonEmptyLinkedList(a) =
    a | (a, NonEmptyLinkedList(a))
    & NonEmptySequence(a)
        def head = this \ case (head, _) | head:  head
        def getEnumerator():
              seq {
                  mut current = this

                loop:
                    yield current.head

                    if (current is (head, tail)):
                        set current = tail
                    else:
                        return
              } 
          


''	Most of the collection types, as well as sequence, provide a non-empty variant. This is because
''	many aggregate functions over a sequence will fail if the sequence yields no elements. A non-empty
''	series of types provides safety from this.




type UserId = UserId int
type User = (id :: UserId, firstName :: string, surname :: string)

type UserRepository = (get :: UserId -> User)

def userRepository = UserRepository (
    get userId:
        User (id = userId, firstName = "Bob", surname = "Jones"))

'' ------- Modules -------

''	A module is a namespace. By default, the module will be based on the path + file name relative to the compilation root.
''  i.e. if the compilation root is in `/src/myproject/` then the file `/src/myproject/function/mod_a.nyx` will have an
''  implicit module name of `function/mod_a`.

''  The module name can be overridden with a module declaration at the top of the file

module my_module_name

''  In a module definitions are "internal" to the module (they cannot be seen outside it) unless they are explicitly exported:

module my_module

def greeting = "Hello world" '' internal

export def greet(): greeting '' Exported, and now visible to other code that imports this module

''  It is highly recommended (compiler warning) that exported definitions have a spec (or are otherwise explicitly typed)
    If desired, you can escape this by giving a value the type of `_` in its spec, which is how you explicitly tell the compiler
    that you want it to infer a type.

module MyModule

export def x = 5 '' Compiler warning: Exported definitions should have an attached spec

''  Modules can also be declared (possibly multiply) in the middle of a file with a module block.
''  The name of the block module will be appended to the name of the containing module
''  Unlike namespaces in object-oriented languages, a module can directly hold values.

module MyModule 

module Functions: '' Full name is MyModule/Functions
    export def f(x): x * 2

    export def g(x): x ** 2

    export def i = 0

'' Static members

type Point = (x :: number, y :: number)
    def origin = Point (x = 0, y = 0)


def Default(Point):
    def default = Point.origin

''	Types are not arranged in a typical heirachy (with with all types ultimately deriving from Object). Instead
''	types are regarded to be derived from another type based on their shapes, so B is assignable to A if B's members
''	are a (non-strict) superset of A's.
''	For example:

spec n :: number -> type
type Point(n) = (x :: n, y :: n)

spec number -> type
type Point3D(n) = (x :: n, y :: n, z :: n)
    def length: sqrt(x * x + y * y + z * z)


spec t -> type where t :: (name :: string)
type NamedList(t):
    ...

''  ------- Importing modules -------

''  Modules can be imported with the `import` keyword, followed by the name of the module. E.g.

import math

''  When importing multiple modules on consecutive lines, it _can_ be written as 

import math
import io

''  But an import block is preferred
import:
    math
    io

''  Imports can be given a local name to avoid name conflicts:
import io/file as f

''  This means that the contents of the `file` module are not available in scope, but instead through the given name `f`
def myFile = f.open("/somefile.txt")

''  Importing can be done anywhere in a file, allowing the use of imports inside scopes to limit naming conflicts
def myFunction():
    import io/file

    file.open("/somefile.txt")




''  ------- Abstractions -------

    Traits are supported.
    where a type is an abstraction over objects, a trait is an abstraction over types.
    
    The Number trait (with the alias `number`) is defined in the standard library as such:

trait Number(t):
    spec (+) :: (t, t) -> t 
      spec (-) :: (t, t) -> t 
      spec (/) :: (t, t) -> t 
      spec (*) :: (t, t) -> t 
    spec one :: t
    spec zero :: t

''	Number essentially forms a type constraint. Int and float both conform and are therefore considered numbers

''	These are very useful for collections. E.g. given the Trait Summable:

trait Summable(t):
    spec (+)  :: (t, t) ->  t
    spec zero :: t


''  Unlike OO languages, traits are not implemented directly by the type in question. The implementation is defined separately:

impl Summable(int):
    def (+) (x, y): x + y
    def zero = 0


''	Enables the Seq.sum function to be defined as:

module Seq:
    [Summable(a)] seq(a) -> a
    def sum(xs) = Seq.fold(xs, (+), zero) '' `+` and `zero` come from `Summable(a)`

''	An important concept in Nyx is that of a type with a default value. This allows the keyword `default` to be used
trait Default(a):
    default :: a

''   This means that the reduce function on sequences does not need a seed value; the type itself can provide one

spec [Default(a)] (list(a), (a, a) -> a) -> a
rec reduce(xs, f):
    xs
    \ case []:  default
      case [head, ...tail]: f(head, reduce(tail, f))



''	------- Dependent types and provability -------

'' 	Types can be refined to allow only certain values

''  They can be used in type aliases:
type Nat = n :: int where n >= 0

''  Or in function signatures:
spec (n :: int) -> int where n >= 0
rec factorial case 0:  1
              case n:  n * factorial (n - 1)

spec (n :: nat) -> y :: int where x >= 0, y >= 1
rec factorial2(n):
    if n = 0: 1
    else: n * factorial2 (n - 1)


def x = -1

print (factorial x) 	''	Compiler error: "Type restriction failure: `int x` has not been shown to satisfy `x >= 0`"

type Nat = x :: int where x >= 0

spec a :: number -> type
type OrderedPair(a) = (x :: a, y :: a) where x < y

spec (int, lower :: int, upper :: int) -> ret :: int where lower <= ret <= upper
def clamp(x, lower, upper): 
    if x < `lower`: lower
       x > `upper`: upper
    else: x


spec (x :: int, y :: int) -> z :: int where (z == x or z == y) and (z >= x and z >= y)
def max(x, y): if x > y: x else: y

class Array(t):
    ...

    spec index :: number -> t where index >= 0 and index < this.length
    def apply(index):
        ...


'' Similar to Typescript, Nyx doesn't support overloading but it does support multiple call signatures on a single function
'' In this way the return type of the function depends on the types passed in

spec case (string, #read) -> ReadableFile
     case (string, #readwrite) -> WriteableFile
def open(filename, mode): 
    ...


''  This is equivalent to, but easier to write than, 
spec (string, mode :: #read | #readwrite) -> 
    mode
    \ case #read: ReadableFile
      case #readwrite: WriteableFile 
def open(filename, mode): 
    ...


'' ------- Type functions --------

    Nyx allows type definitions to be essentially "type functions", i.e. types that calculate other types at compile-time.

type Elem(x):
    x
    \ case String: Char
        case Array[t]: t
        case Iterable[t]: t

''  or:

type Elem (String): Char
        | (Array(t) | Iterable(t)): t



''	------- Lambdas -------

'' a lambda can be written in full:
def f = { x :: int: x * 2 }

'' or, where the target type is known, in shorthand:
def g :: int -> int = { _ + 2 }

''  A shorthand lambda does two things:
    * it allows you to omit the lambda parameter
    * all members of the implicit parameter get lifted into scope (i.e. the function runs _int the context of_ its single parameter)

''  This allows:
def names = people | map { name }

''  As a shorthand for:
def names = people | map { p: p.name }

'' This allows computation expression-style constructs:
def names = seq {
    for people as p:
        yield p.name
}

'' As a rewriting of:
def names = seq({ builder:
    for people as p:
        builder.yield(p.name)	
})


type Point = (x :: int, y :: int)

'' Given the above `Point` class you can initialise it like this:
def p = Point {
    x = 4
    y = 5
}


'' The braces desugar into a lambda passed to the auto-generated `apply` method on the type:
def p = Point.apply({ builder: 
    builder.x = 4
    builder.y = 5
})


'' Since the `apply` method and its lambda parameter are marked as `inline`, the above desugars to:
def __<p-builder>__ = new Point.Builder()
__<p-builder>__.x = 4
__<p-builder>__.y = 5
def p :: Point = __<p-builder>__.build()



''  ------- Builders -------

    Nyx provides a language construct called _Builders_. These are similar to computation expressions in F#
    and a bit like more-powerful versions of Builders from Kotlin

    A builder is used by applying a builder value with a lambda

some_builder {
    '' Some code
}

''  What makes a builder different from other higher-order functions is that extra language constructs are available
    to use inside the lambda, if the builder supports them

    For example, `seq` is in the standard library and is an instance of the SequenceBuilder type.
    `SequenceBuilder` has implemented support for `yield`, so this becomes valid:

seq {
    yield "hello"
    yield "world"
}

''  Note that, while `yield` is included here for learning purposes, it's not actually required and the above is 
    equivalent to:

seq {
    "hello"; "world"
}

''  This desugars to:

seq.apply({ builder ->
    builder.yield("hello")
    builder.yield("world")
})

''  Builders are the preferred syntax for initialising things like maps:
def someMap =
    map {
        yield (1, "one")
        yield (2, "two")
    }

''  Note: the map builder in the standard library uses the contexts feature to provide the `->` operator inside the builder lambda,
    making the preferred form:
def someMap =
    map {
        1 -> "one"
        2 -> "two"
    }

''  Builders are also how async/await is implemented in the standard library. `async` is the instance of the builder
''  and `await` is a custom keyword for the `bind` method

def async = (
    @customKeyword("await")
    def bind(m, f):
        ...
)

def greetingAsync =
    async {
        def name = await get_name()

        return "Hello, {name}"
    }

''  Which is rewritten to:
def greetingAsync =
    async.apply({ builder ->
        builder.bind(get_name(), { name ->
            builder.return("Hello, {name}")
        })
    })


''  Example: HTML builder

def html = (
    def head(body :: HtmlBuilder -> HtmlElement): HtmlElement

    def body(body :: HtmlBuilder -> HtmlElement): HtmlElement

    def apply(block :: [typeof(this)] () -> HtmlElement): HtmlElement
)

def result = html {                                        
    head {                                               
        title { "HTML encoding with Nyx" }
    }
    body {                                               
        h1 { "HTML encoding with Nyx" }
        p {
            "this format can be used as an alternative markup to HTML"                
        }

        '' an element with attributes and text content
        a(href = "http://nyxlang.org") { "Nyx" }

        '' mixed content
        p {
            "This is some"
            b { "mixed" }
            "text. For more see the"
            a(href = "http://nyxlang.org") {
                "Nyx"
            }
            "project"
        }
        p {
            "some text"
            ul {
                for 1..5 as i:
                    li { "{i} * 2 = {i * 2}" }
            }
        }
    }
}

''  ------- Classes (constructors) -------

''  This is a regular type definition

type Option(t) = (#some, t) | #none
    def force():
        this
        \ case (#some, val): val
          case #none: throw (#force_none)

''  This is a constuctor, Nyx's equivalent of a nominal type
    It is both a function and a type definition

    A constructor can be thought of as a type depending on a validation function
    A constructor is a function that takes in any number of parameters and returns the finalised object
    Constructors can be "fallible", where they return an Option

constructor Email(value :: string):
    if Regex("[^@]@[^@]\.[^@]").matches(s):
        Some(value)
    else 
        None

''  This results in a type equivalent to:

type Email = value :: string where isValidEmail(value)
    def static isValidEmail(s :: string):
        Regex("[^@]@[^@]\.[^@]").matches(s)



''  ------- Operators -------

    Operator overloading: while Nyx doesn't allow you to create your own operators, it has a list of operators that
    are considered valid that you can choose from. Some of them are considered "spare", in that they have no pre-defined
    meaning in Nyx, leaving you free to give them your own.

    Primary example: `->`

    Defining operators:

    You can define an operator in the same way as a regular function, but where the name of the function is the operator
    you wish to overload wrapped in brackets. E.g.

    def (->)(a, b): ...


''  ------- Misc -------

    You can use `...` to make code compile without supplying a body. 
    It's a bit like `throw NotImplementedException` but will give a compiler warning.

    Since there's no overloading in Nyx, tuples and tuple types get automatically unwrapped for you.
    For example, `list((string, int))` can just be written as `list(string, int)`. In other languages
    this would be ambiguous but in Nyx it's not.


''  -------- Standard library -------


type MapBuilder = (
    (->) :: (k, v) -> ()
)

type Map = ...
    def apply(block :: [MapBuilder]() -> ()):
        def map = HashMap()

        context(def (->)(k, v): map.add(k, v)):
            block()

        map

def myMap = Map {
    "hello" -> "world"
    "foo" -> "bar"
}


type Option(a) = (#some, a) | #none 
    spec (a -> b) -> Option(b)
    def map(f): this
        \ case #some, val -> (#some, f(val))
          case #none -> #none
          
    def force() :: a: this
        \ case #some, val -> val
          case #none -> throw InvalidOperationException()

type Error(err) = (#error, err)
    spec (err -> a) -> Error(a)
    def map(f): this
        \ case #error, err -> (#error, f(err))

type Ok(result) = (#ok, result)
    spec (result -> a) -> Ok(a)
    def map(f): this
        \ case #ok, val -> (#ok, f(val))

type Result(success, err) = Ok(success) | Error(err)
    spec () -> Option(success)
    def toOption(): this
        \ case #ok, val: (#some, val)
          case _: #none

    spec (err -> a) -> Result(success, a)
    def mapErr(f): this
        \ case #ok, val: #ok(val)
          case error: error

    spec (success -> a) -> Result(a, err)
    def mapOk(f): this
        \ case #ok, val: #ok(f(val))
          case #error, err: #error(err)




