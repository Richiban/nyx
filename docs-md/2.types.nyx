---
  Types
  =====
  # Records

  Records are a way of grouping values together. They are immutable and can contain any type of
  value. Each record property is optionally named; if you do not supply a name then the field is
  said to be 'positional' and its name will be the value of the index of the field. For example,
  the following record:
  None

  Any is the supertype of all types, also called the top type. It defines certain universal
  methods such as equals, hashCode, and toString. Any has two direct subclasses: AnyVal and
  AnyRef.
  
  AnyVal represents value types. There are nine predefined value types and they are
  non-nullable: Double, Float, Long, Int, Short, Byte, Char, Unit, and Boolean. Unit is a value
  type which carries no meaningful information. There is exactly one instance of Unit which can
  be declared literally like so: (). All functions must return something so sometimes Unit is a
  useful return type.
  
  AnyRef represents reference types. All non-value types in Nanyx are reference types, so every
  user-defined record, class, or context inherits from AnyRef.
  
  Here is an example that demonstrates that strings, integers, characters, boolean values, and
  functions are all of type Any just like every other object:


def items: list(Any) = list(
  "a string",
  732,  -- an integer
  'c',  -- a character
  true, -- a boolean value
  { () -> "an anonymous function returning a string" }
)

for items | element -> println(element)

--  This defines a value `items` of type `list(Any)`. The list mixes value and reference types,
--  but every element belongs to `Any`, so the compiler accepts the collection without casts.

--  Here is the output of the program:

```
a string
732
c
true
<function>
```

---
  # Undefined, Nothing, Null

  `undefined` is a subtype of all types, also called the bottom type. There is no value that 
  has type `undefined`.

  A common use is to signal non-termination such as a panic, program exit, or an infinite loop
  (i.e., it is the type of an expression which does not evaluate to a value, or a method that
  does not return normally).

---
  Using the "mapped types" feature, you can make a new type that is a mutable copy of an existing type:

type Person = (name: string, age: int) --  Person is immutable
type MutPerson = Mut(Person) --  MutPerson == `(mut name: string, mut age: int)`

def mutatePerson = { p: Mut(Person) ->
  set p.name = "Fred"
  set p.age = 21
}
    
---
  # Types: Type expressions 
  The powerful type inference means that type annotation are rarely  necessary.

  Some basic types:

  Anything (alias: any. The top type for Nanyx, or the set of all possible values. All types can be assigned to 'any')
  Null (alias -> (). The Unit type for Nanyx. Has only one value: '()')
  Undefined (alias: {}. The bottom type for Nanyx, or the set of no values. 'Undefined' can be assigned to all types.)

  A function can take an argument of type 'any'. This allows any object to be passed in.

---

def f(a: any) = string(a)

---  
  A function with a type of 'undefined' will never return. Either it will loop forever or
  will always throw.

def f: () -> undefined = { panic "not implemented" }

--  Set Operations
--
--  The type system in Nanyx is based on set theory. Defining a value such as `x: string` reads
--  as “x is a member of the set of all strings”. This perspective lets us compose new types
--  and constraints using the following operations:

def x: #stringValue | #intValue = ...  -- (|) is a tag union. Nanyx can only union tags, so to unite
                                        --  different shapes you must wrap the payload in tags.

def x: (string, int) = ...  -- (,) gives the cartesian product of two (or more) sets, i.e. a record.

def x: A & B = ...  -- (&) gives the intersection between two sets. So x is of type A *and* type B.

--  There are some rules around set operations such as:
--  Commutativity:

A | B === B | A

--  Associativity:

(A | B) | C === A | (B | C)

--  Reduction:

A | A == A  

--  Distributivity:

A | (B & C) == (A | B) & (A | C)

(A, B) | (A, C) == (A, B | C)

---
  Nanyx does not support arbitrary unions of unrelated types. Only tags (with optional payloads)
  may participate in a union expression, so wrap other values in tags when you need alternatives.

  The Unit type is so-called because it has exactly one member and can be thought of as '1'
  when it comes to set theory. It is written as `()` (both in type and value) and should be
  interpreted as the empty record, rather than the empty union.
  For example, for any value a => a * 1 === a. In the same way, for any type A, A * () === A.

  This theory extends to the idea of the Bottom type '{}' (the empty set) or 'undefined'. It
  can be thought of as '0' in set theory. For any value a => a * 0 === 0. In the same way, for
  any type A => A * {} === {}

  The empty list `[]` can be thought of as `list(undefined)`. This way the function `.head`
  on `[]` has type `undefined`.

def x = List.head([]) --  x: undefined

--  The above code will always fail and the compiler will highlight the fact that any
--  code after this is unreachable. 



---
  # Records

  Records are a way of grouping values together. They are immutable and can contain any type of
  value. Each record property is optionally named; if you do not supply a name then the field is
  said to be 'positional' and its name will be the value of the index of the field. For example,
  the following record:

type MyRecord = (string, int, data: string)

--  Note that named fields must come last in the record (and therefore positional values must come first)
  
--  Is equivalent to:
type MyRecord = (
  `0`: string
  `1`: int
  data: string
)

  
--  In Nanyx, record types can be thought of as abstract types, or interfaces. When thinking of
--  interfaces think of structural interfaces, meaning that they don't need to be explicitly
--  implemented. Example below:

type Named = ( name: string )

type Person = ( name: string )

def john: Named = Person("John")  --  This is legal even though Person doesn't
                                   --  explicitly derive from Named

def Named.sayHello = { "Hello, my name is {this.name}" }

--  Types can be extended via the mechanism of type intersections ->
type Person = Named & (age: int)

type Pet = (name: string)

def sayName: Named -> string = { named -> "Your name is {named.name}" }

sayName(Person("John"))  --  Valid, as Person explicitly implements Named

sayName(Pet("Rex"))      --  Also valid, as Pet has the right 'shape'
                           --  for Named, even though it doesn't explicitly
                           --  implement it

--  Records can also have optional members.

type Person1 = (name: string; petsName?: string)

--  This could also be modelled with explicit tag unions:

type Person2 = 
  | #noPet(name: string)
  | #petOwner(name: string, petsName: string)

--  When destructuring `Person2`, `petsName` exists only inside the `#petOwner` branch. If you
--  want to expose it as `string?`, convert the union explicitly (for example, by returning
--  `#none`/`#some petsName`).

--  Enums can be modelled through tag unions. Example ->
  
type Colour = #red | #green | #blue

--  Discriminated unions are just tag unions whose payload is a record ending up in the first
--  position. The tag acts as the discriminator, while the record carries additional data.

type Shape = 
  | #circle(radius: number)
  | #rectangle(width: number, height: number)

--  You can then pattern match on the tag to extract the values:
def area: Shape -> number 
  = { | #circle(radius)           -> Math.pi * radius ** 2
      | #rectangle(width, height) -> width * height }

type ContactInfo = 
    | #nil
    | #telephone(string)
    | #email(string)
    | #emailAndTelephone(email: string, telephone: string)

--  Usage: 

def sendMessage: ContactInfo -> ()
  = { | #nil                                 -> () --  Do nothing
      | #telephone(telephone)                -> sendSMS(telephone)
      | #email(email)                        -> sendEmail(email)
      | #emailAndTelephone(email, telephone) ->
        sendEmail(email)
        sendSMS(telephone) }

--  There is no direct equivalent of 'void' from other languages; the value/type 'unit' is used 
--  instead to indicate that a function returns nothing useful

def writeToConsole: string -> ()
  = { message ->
    ...
  }

--  Record types can be defined inline at the point of their use.
def calculateDistance = { (point: (x: int, y: int)) ->
    Math.sqrt(point.x ^ 2 + point.y ^ 2)
}

--  Records can be combined
type A = ( a: string )
type B = ( b: string )

def obj: A & B = ( a = "a", b = "b" )


-- 
  Nominal types

  Sometimes the name of a type is what's significant about a type, rather than its shape.
  Nanyx provides nominal and nominal-private (aka opaque types) types.

  A nominal type cannot be constructed (or cloned) outside of its home module. To make it
  useful you need to write and export a constructor function.

type @User = (
  id: UserId
  name: string
)

---

  A nominal-private type (also known as an opaque type) is one whose structure 
  is completely hidden outside its home module. Constructor and accessor functions 
  need to be written for these types to be useful. Opaque types are most often written to
  wrap primitives.

type @UserId = private string

---
  Contexts can also be nominal. This is very common in the standard library and in hosts;
  for example @Console and @Memory