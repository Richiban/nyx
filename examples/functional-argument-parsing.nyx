type Config = (
  help   : bool   = false
  verbose: bool   = false
  input  : string = ""
)  

type Arguments = list(String)

type CliConfigM = StateT(Config, ReaderT(Arguments, Err(String)))

def indexOf: [Eq(α) + Seq(s)] s(α), α, (start: Nat = 0) -> Nat?
  = { xs, s, start ->
    match xs
    | [] -> None
    | [{ == s }, ..] -> #some(start)
    | [_, ..tail] -> indexOf(tail, s, start = start + 1)
  }

def requiredArgument: String -> ReaderT(Arguments, Except(String), String) 
  = reader { name ->
    def args = do read
    
    def value = 
      match indexOf?(args, name)
      | #some(i) if i + 1 < args.length -> args(i + 1)
      | _ -> ""
      
    if value == "" -> throw "Command line argument {name} is missing"
    
    return value
  }

def optionalSwitch: String -> ReaderT(Arguments, Err(String), bool) 
  = reader { name ->
    def args = read ()
    
    return match indexOf(args, name)
    | Some _ -> true
    | None -> false 
  }

def parseArguments: CliConfigM(bool) = {
  mut config = read ()

  if bind optionalSwitch "--help" ->
    throw "Usage: example [--help] [--verbose] [--input <input file>]"
    
  set config = { config ->
    verbose = bind optionalSwitch "--verbose"
    input = bind requiredArgument "--input"
  }

  set config
  return true
}

def main: [Console] List(string) -> () = { args ->
  def config: Config = ( input = "default" )

  match parseArguments \run(config) \run(args)
  | #some (_, c) ->
    println("Processing input '{c.input}' verbose={c.verbose}")
  | #err(e) -> println("Error: {e}")
}

#eval main ["--input", "foo.txt", "--verbose"]