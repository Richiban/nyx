---
Type inference and specs
==============

Type inference is foundational part of Nyx.

---

def message = "Hello world" -- This is implicitly a String

def message: string = "Hello world" -- This is explicitly a String

---
Note that the type is inferred from the value; that does not mean that the type is dynamic.

Arguments to functions can also be inferred.

---

def add = { a, b -> a + b } -- `add` is inferred to have the type `(int, int) -> int`

---
While leaving the compile to infer types is convenient, it is recommended that types be specified
explicitly for values and functions that are exported from a module.

---

export def add = { a, b -> a + b } -- Compiler warning: `add` has no type annotation

---
It's possible to specify the type of a value or function inline, using a type annotation:

---

export def add: Nat, Nat -> Nat = { a, b -> a + b }


---
Target-typing

Target-typing refers to type inference based on how a value is used, rather than how it is assigned.

For example, given the following function `parse` and the value `:

---
def parse: string -> Î± = { json -> ... }

def obj = parse("{}") --  What type is `obj`? The compiler leaves it as `a` until the variable is used

--  You can specify the type using a type assertion expression

def obj = parse("..."): Person

--  Or by assigning the result to an explicitly typed variable later on:

def personObj: Person = obj

--  This can be thought of as schroders variable, where the type of the variable remains unknown
--  until it is used in a context where the type _is_ known.


--  Target-typing is also used for collections:
def myItems = [1, 2, 3] -- `list(int)` is inferred as the "natural type" for the collection
def myItems = [1, 2, 3]: MutList(string) --  The type can be specified explicitly
def myItems = MutList[1, 2, 3] --  This form is also supported

def myMap = [1 => "one", 2 => "two"] -- `int -> string` is inferred as the "natural type" for the collection

--  Here we see the type specified on the LHS
def myLookup: Lookup(int, string) = [1 => "one", 1 => "uno", 2 => "two", 2 => "dos"]

def myLookup = Lookup[1 => "one", 1 => "uno", 2 => "two", 2 => "dos"] --  This form is also supported



--  --	Specs --
--  Specs are a syntax for writing the type of a definition separately. They are optional but are recommended for exported functions

--  Types can be specified inline in Nyx with the `:` syntax, for example:

def x: string = "Hello world"

---
Exported functions should be given a type annotation; you'll get a compiler warning if you don't.

Specs can optionally specify the name of the definition they apply to. This would normally be ommitted
on definitions (where the definition immediately follows the spec) but is required on specs present in 
a trait where there is no definition attached

For example:

---

trait MyTrait ->
  spec aMethod: (string -> string) --  Spec name required (no definition is attached)

  spec string -> string
  def anotherMethod(x) -> x --  Spec name can be omitted because it is attached to a definition
  