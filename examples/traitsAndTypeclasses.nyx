--  Some types are meant to be implemented directly
--  This is an ".. is a .." relationship
type Iterator(α) = (moveNext :: () -> α | #done)

type Seq(α) = (getIterator :: () -> Iterator(α))

type Collection(α) = 
  Seq(α) & 
  (size :: () -> int)
    
type Set(α) = 
  Collection(α) & 
  (contains :: a -> bool)

type SortedSet(α) = 
  Set(α) & 
  (min :: a; max :: a)

type NumericRange(a :: number) = 
  SortedSet(α)
  & (min :: a, max :: a) where min <= max

--  Others are meant to be implemented via a separate instance
--  This is a "there exists a .. for .." relationship
context Monad(m: type -> type) = (
  lift: a -> m(α)
  bind: m(α), (a -> m(β)) -> m(β)
)

default Monad(Option) = (
  bind = {
    | #some(x), f -> f(x)
    | #nil, _     -> #nil
  }

  lift = { x -> #some(x) }
)

--  For example, there is a Monoid type, and int can be made into a monoid
--  But, crucially, there are multiple ways to make a monoid out of int
--  such as addition, multiplication, bitwise and, bitwise or, etc.

context Monoid(α) = (
  empty:   α
  combine: α, α -> α
)

def additiveMonoid: Monoid(int) = (
  empty = 0
  combine = { x, y -> x + y }
)

def multiplicativeMonoid: Monoid(int) = (
  empty = 1
  combine = { x, y -> x * y }
)

def bitwiseAndMonoid: Monoid(int) = (
  empty = 0
  combine = { x, y -> x .& y }
)

def bitwiseOrMonoid: Monoid(int) = (
  empty = 0
  combine = { x, y -> x .| y }
)

def reduce: [Monoid(α)] Seq(α) -> α
  = { xs ->
    xs \fold(empty, combine)
  }

def sum(xs) = use MultiplicativeMonoid in reduce(xs)

type Point = (x: int, y: int)

def points = Point[
  (1, 2)
  (3, 4) 
  (5, 6)
]

def Point.`+` = { a, b -> Point(x = a.x + b.x, y = a.y + b.y) }

def Point.`0` = Point(x = 0, y = 0)

context Sum(α) = (
  `0`: α
  `+`: α, α -> α
)

--  We could explicitly define the Sum typeclass instance for Point, but
--  we don't need to; one can be synthesized from the `+` and `0` methods that
--  are defined on Point.
--  These methods are in the global context, so narrower contexts can be automatically
--  synthesized from them.
default Sum(Point) = (
  `0` = Point(x: 0, y: 0)
  `+` = { a, b -> Point(x: a.x + b.x, y: a.y + b.y) }
)

def sum: [Sum(Point)] List(Point) -> Point
  = { items ->
    items \fold(0) { + }
  }

def r = points \sum