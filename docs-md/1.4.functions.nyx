---
Functions
=========

An important difference between Nanyx and many other languages is that all functions take exactly one argument
and return exactly one result.
This means that there is only one function signature in Nanyx: `a -> b`, where `a` is the type of the input and `b`
is the type of the output.

This doesn't sound terribly useful until you consider that records allow you to pass multiple values as one
value. In addition, destructuring syntax can be used in the function definition to extract the values from the 
record, which feels like a function that takes multiple arguments:

---

def add = { x, y -> x + y }
  -- `add` has the type `(int, int) -> int`; that is a funcion that takes a record of two ints
  -- and returns an int

--  What about functions that take no inputs, or return no output?
--  The type `()` is the type of the value `()`, which is the only value of the type `()`. This is called the 
--  "Unit type", and is essentially a record with no elements.
--  In Nanyx, if your function returns unit, you don't need to explicitly return it. This makes it feel like a `void`
--  function from other languages:

def printHello = {
  println("Hello")
    -- `printHello` has the type `() -> ()`. Notice that we don't need to write `return ()` in 
    -- the function body
}

--  Since Nanyx contains many concepts from functional programming, it is useful to be able to easily
--  write a function literal. This is done with braces:
def print1 = { print("1") }


--  The braces form creates a lamda, which facilitates higher-order functions. For example:
def names = data \map { item -> item.name }

--  lambdas also have a short form:
def names = data \map { .name }
def doubledAged = data \map { + 2 }
def add = { + }

Web.makeRequest(
  url = "http://some.api.com/"
  success = { error?, response?, data? ->
    println("The response was {data}")
  }
  failure = { error ->
    println("There was an error: {error}")
  }
)

--	This sumList example defines a function making use of a match expression.
rec sumList = { (xs: list(int)) -> match xs
  | []              -> 0
  | [head, ...tail] -> head + sumList tail
}

rec sumList
  : list(int) -> int
  = { xs -> 
    match xs
    | []              -> 0
    | [head, ...tail] -> head + sumList tail
  }


--	Since a function that consists of a single match expression is so common in Nanyx,
--  you can merge the function definition and | statements together, dropping the need to name an argument
rec sumList = {
  | []              -> 0
  | [head, ...tail] -> head + sumList(tail)
}

--  If you feel that the function definition has suffered from the loss of the argument name, you can
--  use a type annotation to reinstate it. Note: type annotations are always recommended for exported functions
rec sumList 
  : list(int) -> int 
  = { 
    | []              -> 0
    | [head, ...tail] -> head + sumList(tail) 
  }

--  Also note that, since functions in Nanyx are defined in record form, it's possible to pattern match immediately
--  on multiple arguments:
def divide
  : int, int -> Result(int, #divideByZero)
  = { 
    | _, 0 -> Err(#divideByZero)
    | x, y -> x / y 
  }

--  An equivalent form exists for lamdas consisting solely of a single pattern match:
def count = {
  | 0 -> "zero"
  | 1 -> "one"
  | _ -> "many"
}

--	Simple member access can be turned into a function as such ->
def namesAndAges =
  [| name 		  | age	|
   | "Felix" 		| 22	|
   | "Taylor"   | 30	|
   | "Peter" 		| 28	|
   | "Sean" 	  | 45	|]

def ages = namesAndAges \map { .age }

---
If you want a parameter to be optional, prefix its name with a ?
Note that any optional parameters will automatically be wrapped in an option type.
The compiler handles optional parameters by inserting None at the callsite.

---

def printMessage = { ?message -> 		--	"message" is of type `string?` (short for `Option(string)`)
  message 
  \match
    | #nil       ->  "You didn't say anything"
    | #some, msg ->  "You said -> {msg}" 
  \println
}

---
You can also make parameters optional by giving a default value. In this | the type of
the parameter is still `Option(t)` as far as any callers are concerned but the type is
automatically unwrapped for you inside the method. If None was supplied at the callsite
then it will be substituted for the default value you gave in the method declaration

---
printResults(left = "left", middle, right = "right") ->
print "{left}, {middle}, {right}"

printResults("1", "2", "3")	--	legal
printResults("1", "3")			--	legal
printResults"1"				--	Not legal
printResults()					--	Not legal
printResults(middle = "2")		--	Legal. Instead of supplying each argument individually you can supply an
              --	object with the same shape as the list of parameters. More examples ->

--	Function arguments can be thought of as a single object with a number of properties.
type Person = (name: string, age: string)

def john = Person("John", 28)

def f = { name: string, age: int -> "{name} is {age} years old." }

f(john.name, john.age)	--	Conventional method call
f(john)					--	This is legal as the object 'john' has the right shape for the collection of
      --	parameters for the function f.


--	An incomplete expression (including operators, indexers and member calls) can be wrapped in
--  parentheses to turn it into a function.
double = (* 2)
double 5 		--	=> 10

def names = "John", "Adam", "Alexander"
def backwardsNames = names \map { reverse() }	--	=> ["nhoJ", "madA", "rednaxelA"]
def firstLetters = names \map { x -> x(0) }			--	=> ["J", "A", "A"]
def longNames = names \filter { length > 5 } 	--	=> ["Alexander"]


--  Functions can be composed. Think of it as pre-preparing a pipe
def firstThree = { (str: string) -> str.substring(0, 3) }
def reverse = { (str: string) -> str.reverse() }

def lastThree = reverse >> firstThree >> reverse

--  The following two statements are equivalent
"Hello" \(reverse >> firstThree >> reverse)	--	=> "llo"
"Hello" \reverse \firstThree \reverse		--	=> "llo"


--  Functions have the signature `a -> b`, where `a` and `b` are the types
--  of the function's input and output, respectively.
--  All functions in Nanyx take *one* value as input and product one value as output.
--  This doesn't sound very useful until you consider that records allow you to
--  pass multiple values as one and unit allows you to return no values.

--  Functions are not the only objects that have this signature `a -> b`, however.
--  The type `a -> b` is called a `mapping`, and there are a number of mappings in Nanyx, not
--  just functions. Dictionaries are an example, as are strings. Any object of type
--  `map` is considered 'applicable', and can be 'called' just like a function

def f: int -> int = { * 2 }

f(2)					--  4

def dict: string -> string = [ "Hello" => "Bonjour"; "Goodbye" => "Au revoir" ]

dict("Hello")		-- "Bonjour"

def greeting = "Hello, "

greeting("John")		-- "Hello, John"

--  Note: there is no overloading in Nanyx. With optional/named parameters and tag unions
--  there is so little need for overloading that it's not worth the considerable 
--  complication to the compiler and type system


-- Notice that we have the option of putting parameter names in our function signatures
-- but we don't have to. It's the choice of the function author as to whether they want
-- their parameter names to form part of the signature and become named parameters rather
-- than positional

-- for example: 

def replace: (string, string, string) -> string = { source, origin, replacement -> ??? }

replace("Hello world", "world", "Nanyx")


-- If we switch to named parameters in our signature then callers now must use named 
-- parameters as well:

def replace: (string, replace: string, with: string) -> string = { s, o, r -> ??? }

replace("Hello world", replace = "world", with = "Nanyx")

