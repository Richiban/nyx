# Records and Tuples

Records and tuples are fundamental data structures in Nanyx. They allow you to group related values together with or without names.

## Records

Records are structural types with named fields enclosed in parentheses:

```nyx
-- Record creation
def user = (
  name = "Alice"
  age = 30
  email = "alice@example.com"
)
```

## Record Types

Define record types to describe the shape of your data:

```nyx
type Person = (
  name: string
  age: int
  email: string
)

-- Using the type
def alice: Person = (
  name = "Alice"
  age = 30
  email = "alice@example.com"
)
```

## Accessing Record Fields

Access fields using dot notation:

```nyx
def user = (name = "Bob", age = 25)

def userName = user.name  -- "Bob"
def userAge = user.age    -- 25
```

## Record Updates

Records are immutable. Updates create new records:

```nyx
def user = (name = "Alice", age = 30)

-- Create new record with updated field
def olderUser = user with age = 31

-- user is unchanged
-- olderUser = (name = "Alice", age = 31)
```

## Nested Records

Records can contain other records:

```nyx
type Address = (
  street: string
  city: string
  zipCode: string
)

type Person = (
  name: string
  age: int
  address: Address
)

def person = (
  name = "Alice"
  age = 30
  address = (
    street = "123 Main St"
    city = "Springfield"
    zipCode = "12345"
  )
)

-- Access nested fields
def city = person.address.city  -- "Springfield"
```

## Record Destructuring

Extract fields from records with pattern matching:

```nyx
def user = (name = "Bob", age = 25)

-- Destructure in definition
def (name = userName, age = userAge) = user

-- Destructure in function parameter
def greet: Person -> string = { (name = n, age = a) ->
  "Hello {n}, age {a}"
}

-- Partial destructuring
def (name = name, _) = user  -- only extract name
```

## Tuples

Tuples are anonymous records with numbered fields:

```nyx
-- Tuple creation
def point = (10, 20)

-- Access by position
def (x, y) = point

-- Tuple type
def origin: (int, int) = (0, 0)
```

## Named Tuples

You can name tuple fields, making them equivalent to records:

```nyx
-- Named tuple
def coords = (x = 10, y = 20)

-- Access by name
def x = coords.x  -- 10

-- Or destructure
def (x = xVal, y = yVal) = coords
```

## Record Patterns in Matching

Use records in pattern matching:

```nyx
type Point = (x: int, y: int)

def classify: Point -> string = { point ->
  match point
    | (x = 0, y = 0) -> "origin"
    | (x = 0, y = _) -> "on y-axis"
    | (x = _, y = 0) -> "on x-axis"
    | (x = x, y = y) if x == y -> "on diagonal"
    | _ -> "general point"
}
```

## Records as Function Parameters

Records make multi-parameter functions natural:

```nyx
-- Function taking multiple parameters
def calculateArea: (width: int, height: int) -> int = { width, height ->
  width * height
}

-- Call with named arguments
def area = calculateArea(width = 10, height = 20)

-- Or with a record
def dimensions = (width = 10, height = 20)
def area2 = calculateArea(dimensions)
```

## Structural Typing

Records use structural typing - they're compatible based on shape, not name:

```nyx
type Point2D = (x: int, y: int)
type Coord = (x: int, y: int)

-- These are the same type!
def point: Point2D = (x = 10, y = 20)
def coord: Coord = point  -- OK!
```
