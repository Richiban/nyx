---
   In Nanyx, mutation is available but is bounded. You must open a memory context in order to create 
   mutable variables or use mutable collections.

   This makes it possible to implement pure functions that internally use mutable state and 
   destructive operations, as long as these operations are confined to the given region.

   We can use local mutation when it is more natural or efficient to write a function using
   mutable data and in an imperative-style while still remaining pure to the outside world.

   We can use a memory context to implement a pure sort function that internally uses mutation:

def sort: [Ord(a)] list(a) -> list(a) = { l ->
    memory {
        def arr = MArray.of(l)
        MArray.sort(arr)
        MArray.toList(arr)
    }
}

def main = {
   -- Compiler error: No such context keyword `mut`. Did you mean to open a `memory` context?
   def x = mut 0 

   x := 1
}

def main = {
   memory {
      def x = mut 0 -- OK

      x := 1
   }
}

def main = {
   def mutateX: <@Memory> MRef(int) -> () = { x ->
      x := 1
   }

   memory {
      def x = mut 0

      mutateX(x)
      
      println(x) -- Prints 1
   }
}

---

def main = {
   def items: MList(int) = [] -- Error: Instantiating a MList requires a memory context

   items += 1
   items := items ++ [2, 3]

   println(items) -- [1, 2, 3]
}

def main = {
   memory {
      def items: MList(int) = []

      items += 1
      items := items ++ [2, 3]

      println(items) -- [1, 2, 3]
   }
}

---
   Global mutable state is something that's discouraged in almost every language, and in Nanyx
   it's actually impossible. We don't have a dedicated rule that says that you cannot have mutable
   global state but, due to Nanyx's context system and the in-built memory context, it becomes 
   impossible to create the context necessary to declare a mutable value.

   Trying to create a mutable reference at the top level results in this:


def x = mut 0 -- Compiler error: can only create a `mut` reference in a memory context

---
   As well as `mut`, the memory context also provides `ref` for immutable references. normally
   one lets the compiler decide whether a value should be passed by copying or by a reference, but
   you can force it. This is rather rare

type Counter: <@Memory> =
   (counter: Ref(int))

def newCounter: <@Memory> () -> Counter = { Counter(counter: Ref.new(0)) }

def getCount: <@Memory> Counter -> int = { c ->
   def Counter.Counter(l) = c
   Ref.get(l)
}

def increment: <@Memory> Counter -> () = {
   def Counter.Counter(l) = c
   Ref.put(Ref.get(l) + 1, l)
}

def main: [] () -> () = {
   region rc {
      def c = newCounter(rc)
      increment(c)
      increment(c)
      increment(c)
      getCount(c) |> println
   }
}