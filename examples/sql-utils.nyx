module Agilogy.Arrow2.Sql

import (
  Arrow.Core.Continuations.Raise
  Nyx.Sql.Connection
  Nyx.Sql.PreparedStatement
  Nyx.Sql.SQLException
  Nyx.Sql.DataSource
)

def DuplicateKey = ()

type SqlPrimitive = #sqlInt | #sqlString

spec [Connection, Raise(Nothing)] (string, seq(SqlPrimitive)) -> Async(int)
def executeUpdate(query, args) -> async {
  def ps = use prepareStatement(query)
  
  for 0.., args | pos, arg ->
    ps \setArgument(pos, arg)
    
  ps.executeUpdate()
}


def executeUpdateCatchDuplicateKey
  : [Connection + Raise(DuplicateKey)] string, seq(SqlPrimitive) -> Async(int)
  = async { query, args ->
    match executeUpdate(query, *args)
      | Err(#SQLException, e) if isDuplicateKey(e) ->
        raise(DuplicateKey)
      | Err(#SQLException, e) -> 
        return e
  }


def setArgument
  : PreparedStatement, int, SqlPrimitive -> ()
  = { | smt, pos, #sqlInt -> smt \setInt(pos, arg.value)
      | smt, pos, #sqlString -> smt \setString(pos, arg.value)
      | _ -> ()
    }

def withConnection
  : [Raise(e)] DataSource, ([Raise(e) + Connection] () -> α) -> α
  = { dataSource, f ->
    use getConnection()
      
    f(dataSource, dataSource)    
  }