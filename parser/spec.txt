**Nyx Language Specification (April 2025 Edition â€” Context Capture Model + Tag Corrections)**

---

# Introduction

Nyx is a statically typed, functional-first programming language with:

* Hindley-Milner type inference
* Explicit, composable context system
* Workflows based on context passing
* Clean modules and imports
* Lightweight, ergonomic syntax

Nyx aims to combine the best of Haskell, F#, Roc, and modern practical languages.

---

# Core Concepts

## Functions

* Functions are defined with `def name { params -> body }`.
* Functions are **not curried** by default.
* Functions that require a context **are curried** on the context.

Example:

```nyx
def add
  : (Int, Int) -> Int
  = { x, y -> x + y }
```

---

## Contexts

### What Are Contexts?

* Contexts represent capabilities a function requires.
* Declared with `[ContextName]` after the function name.
* Multiple contexts are comma-separated.

Example:

```nyx
def logMessage [Console]
  : (String) -> ()
  = { msg -> print(msg) }
```

### Context Desugaring

A function with contexts desugars into a **curried function** capturing the context:

```nyx
def f [ctx]
  : (A) -> B
  = { x -> body }
```

desugars to:

```nyx
def f
  : ctx -> (A -> B)
  = { ctx -> { x -> body } }
```

* The context (`ctx`) is the first argument, curried in.
* Normal parameters follow.

### Multiple Contexts

Multiple contexts are curried left to right:

```nyx
def f [Console, Database]
  : (A) -> B
```

desugars to:

```nyx
def f
  : Console -> Database -> (A -> B)
```

### Explicit Context Application at Call Site

You can **explicitly provide** a context using `[ContextInstance]` syntax:

```nyx
def x = f[ctx](arg)
```

Desugars to:

```nyx
def x = (f(ctx))(arg)
```

* Matches declaration syntax.
* Allows partial application.

Example:

```nyx
def greet = logMessage[console]
greet("Hello!")
```

---

# Workflows

### What Are Workflows?

* Workflows are blocks tied to a specific context.
* Each workflow defines:

  * A context type
  * A bind word (e.g., `await`, `try`)
  * `pure`

### Workflow Syntax

```nyx
workflowName {
  def x = bindWord expr
  pure expr
}
```

### Workflow Desugaring

A workflow block:

```nyx
workflowName {
  def x = bindWord expr
  def y = bindWord expr2
  pure y
}
```

desugars to:

```nyx
workflowName { ctx ->
  ctx.bindWord(expr, { x ->
    ctx.bindWord(expr2, { y ->
      ctx.pure(y)
    })
  })
}
```

* `ctx` is explicitly passed in.
* Binding happens through methods on `ctx`.

### Binding Function Type

The bind function must have type:

```nyx
(M a, (a -> M b)) -> M b
```

where `M` is the monadic type for the workflow (e.g., `Async`, `Result`).

---

# Modules and Imports

* Each file can declare `module Name`.
* Functions/types are private by default.
* Explicit exports: `export foo, bar`.
* `open ModuleName` to bring names into scope unqualified.

# Types

* Hindley-Milner type inference.
* Tags for sum types.
* Open union types using `| _`.

### Tags with Payloads

Tagged values carrying payloads use **direct form**, not tuples.

Example:

```nyx
type Option a =
| #some a
| _
```

Pattern matching:

```nyx
match opt
| #some v -> ...
| _ -> ...
```

If multiple fields are needed, parentheses can be used:

```nyx
| #error (code: Int, message: String)
```

# Pattern Matching

```nyx
match value
| pattern1 -> expr1
| pattern2 -> expr2
| _ -> defaultExpr
```

* Match arms and union types must begin with `|`.

# Pipelines

* Use `\` operator to pipe values.

```nyx
xs \map { * 2 } \filter { x -> x > 3 }
```

# String Interpolation

* Use `{}` inside strings:

```nyx
print("Hello {name}!")
```

# Trailing Lambdas

* Last function argument can be a trailing lambda.

```nyx
xs \map { x -> x + 1 }
```

# Operators

* Use backticks to define custom operator functions.

```nyx
def Point.`+` [Grid]
  : (Point, Point) -> Point
```

# Projects

* Single file projects are supported.
* `.nyxproj` files (TOML format) define larger projects.

---

# End of Draft (Context-Captured Nyx Model with Correct Tag Matching)

---
