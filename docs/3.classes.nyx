--  Nyx doesn't support the classic object-oriented notion of a class, but due
--  to a concise object syntax and closure support, it's easy to simulate (as long
--  as you don't want inheritance).

--  For example this Scala class

--  class Point(var x: Int, var y: Int):

--    def move(dx: Int, dy: Int): Unit =
--      x = x + dx
--      y = y + dy

--    override def toString: String =
--      s"($x, $y)"
--  end Point

--  val point1 = Point(2, 3)
--  println(point1.x)  // prints 2
--  println(point1)    // prints (2, 3)

--  Can be represented in Nyx with:

type Point = { x: int, y: int ->
  ( x
    y
    move = { dx: int, dy: int ->
      Point (
        x = x + dx
        y = y + dy
      )
    }
  )
}

default PointExtensions = (
  def toString(p: Point): string ->
    "({p.x}, {p.y})"
)

--  Note that the Point object above uses "non-destructive mutation" or "copy-and-update"


--  Naming the function with a capital first letter doesn't change its behaviour, but it 
--  cause a type with the same name to be generated as well, similarly to if we'd written
--  this:

type Point = (x: int, y: int, move: (dx: int, dy: int) -> Point)
def point(x: int, y: int): Point ->
  Point(
    x
    y
    def move(dx: int, dy: int) ->
      x = x + dx
      y = y + dy
  )

--  Despite the fact that this is just a function, we call this a "constructor"


def f [Show(Point)] { p: Point ->
  p \toString
}

  
--  -- OO-style programming and classes --

--  Nyx doesn't have classes or inheritance, but there are easy ways to encapsulate state 
--  and functions together.

--  If a class is required because it has mutable state or private functions, you can
--  write a constructor function on the type that returns a record with the necessary
--  state or functions captured in the returned object

--  Normally definitions are written with a lowercase starting character, and uppercase
--  characters are for types.  However, Nyx also has the feature where you can write a
--  definition with an uppercase starting character, and a type will be generated for you,
--  with the same name, for the return type of the definition.  

--  For example, this definition is both a function and a type, and quite nicely emulates a class:
type Counter = { count: int ->
  mut count = count

  ( increment = { count += 1 }
    decrement = { count -= 1 }
    count = { count }
  )
}

--  If this definition had been written `def counter` then it would have had the type:
--  `(count: int) -> (increment: () -> (); decrement: (): (); count: int)`
--  but, thanks to the uppercase first character, its type is now:
--  `(count: int): Counter`

--  This is equivalent to these two definitions:
type Counter = (
  increment: () -> ()
  decrement: () -> ()
  count: int
)

def Counter: int -> Counter = { count ->
  mut count = count

  ( increment = { count += 1 }
    decrement = { count -= 1 }
    count = { count}
  )
}

--  It's important to remember though that this form is still ultimately just a function definition,
--  although it acts a lot like a constructor
type ResourceController = { repo: ResourceRepository ->
  ( get = { id -> repo.get?(id) \Option.map(toJson) }
    post = { data -> repo.save(data) }
  )
}
  
--  It's also possible to specify the list of "interfaces" that your type "implements"
type Rule = (divisor: int, word: string)

--  For example, this type implements the `Seq` "interface":
type NumberGame: seq(Rule) = { rules: seq(Rule) ->
  ( getIterator = { rules.getIterator() }
    apply = { n ->
      rules
        \select { rule -> if n % rule.divisor == 0 -> #some(word) else -> #skip }
        \joinString("")
        \match
          | "" -> string(n)
          | s  -> s 
    }
  )
}

--  -- Classes (constructors) --

--  Nyx doesn't have classes, but you can simulate a lot of what classes do with simple functions 

--  For example, a class with a constructor and a method:

type Person = { name, age ->
  mut age = age --  Shadow the `age` variable with a mutable version

  --  Return the object representing the class instance
  ( name = name
    age = { age }
    setAge = { newAge -> set age = newAge }
    toString = { "{name} is {age} years old" }
    ageDiff = { (other: Person) -> 
      abs(age - other.age)
    }
  )
}
  
  --  This is a regular type definition
  
type Option(t) = #some(t) | #nil

def Option.force(this) ->
    match this
      | (#some, val) -> val
      | #nil -> throw (#force_none)
  
--  This is a type def, Nyx's equivalent of a nominal type
    It is both a function and a type definition

    A type def can be thought of as a type depending on a validation function
    A type def is a function that takes in any number of parameters and returns the finalised object
    type defs can be "fallible", where they return an Option
  
def Email?(value: string) ->
    if s \Regex.matches("[^@]@[^@]\.[^@]") ->
        #some(value)
    else 
        #nil
  
  --  This results in a type equivalent to:
  
  type Email = value: string where isValidEmail(value)
      def static isValidEmail(s: string) ->
          Regex("[^@]@[^@]\.[^@]").matches(s)
  
  