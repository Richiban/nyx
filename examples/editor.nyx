module lines

import
  Editor
  Enumerable
  Utils.Lines as lineUtils
  SelectionsAndRanges 
  Io/SubjectIOBase 

export type LinePair =
  | #firstLine(prev: #nil, current: TextLine)
  | #lastLine(prev: TextLine, current: #nil)
  | #line(prev: TextLine, current: TextLine)

export type Direction = #backwards | #forwards
export type Change = #greaterThan | #lessThan

def changeToDiff
  : Change -> (number, number -> number)
  = { | #greaterThan -> { > }
      | #lessThan    -> { < } }

export def getNearestSignificantLine
  : TextDocument, Position -> TextLine
  = { document, position ->
    def currentLine = document.lineAt(position.line)

    if currentLine.isEmptyOrWhitespace ->
      def lines = lineUtils.iterLinesOutwards(document, position.line)

      for lines | backwardsLine, forwardsLine ->
        if backwardsLine is #some(line) and not line.isEmptyOrWhitespace ->
          return backwardsLine

        if forwardsLine is #some(line) and not line.isEmptyOrWhitespace ->
          return forwardsLine

    currentLine
  }


export def rangeWithoutIndentation
  : TextLine -> TextLine
  = { line ->
    line.range with (
      start = line.range.start with (
        character = line.firstNonWhitespaceCharacterIndex
      )
    )
  }

export def getNextLineOfChangeOfIndentation
  : [Document] Change, Direction, TextLine -> #some(TextLine) | #nil
  = { change, direction, currentLine ->
    def diff = changeToDiff(change)

    def lines = iterLines(
      startingPosition = currentLine.range.start
      direction
      currentInclusive = false
    )

    lines
      \filter { l -> not isEmptyOrWhitespace(l) }
      \filter { l -> diff(l.firstNonWhitespaceCharacterIndex, currentLine.firstNonWhitespaceCharacterIndex) /= 0 }
      \tryHead
      except #notFound -> #nil
  }

export def getRelativeIndentation
  : TextLine, TextLine -> RelativeIndentation
  = { startingLine, targetLine -> 
    if 
    | targetLine.isEmptyOrWhitespace ->
      #noIndentation
    | startingLine.firstNonWhitespaceCharacterIndex > targetLine.firstNonWhitespaceCharacterIndex ->
      #lessIndentation
    | startingLine.firstNonWhitespaceCharacterIndex < targetLine.firstNonWhitespaceCharacterIndex ->
      #moreIndentation
    | else ->
      #sameIndentation
  }

export def iterLinePairs
  : TextDocument, IterationOptions -> Source(LinePair)
  = { document, options ->
    iterLines(document, (options with currentInclusive = true))
      \pairwise
      \map {
        | a, b where options.direction == #forwards -> (prev = a, current = b)
        | a, b -> (prev = b, current = a)
      }
  }

 
export def getNextSignificantLine
  : TextDocument, Position, Direction -> #some(TextLine) | #noLine
  = { document, position, direction ->
    def lines = document \iterLines(
      startingPosition = position
      direction = direction
      currentInclusive = false
    )

    lines \tryFind(lineIsSignificant) except #notFound -> #noLine
}

--  A "stop line" is one that is either blank or contains only punctuation
export def lineIsStopLine
  : TextLine -> bool
  = { line -> 
    not (line.text \RegEx.matches("[a\zA\Z0\9]"))
  }

export def lineIsSignificant: TextLine -> bool
  = { line -> !lineIsStopLine(line) }

def moveToChangeOfIndentation
: [TextEditor] Position, common.Change, common.DirectionOrNearest -> ()
= { cursorPosition, change, direction ->
  if cursorPosition and document ->
    mut line: TextLine? = #nil
    def currentLine = document.lineAt(cursorPosition.line)

    match direction
      | #nearest ->
        set line = getNearestLineOfChangeOfIndentation(
          document,
          document.lineAt(cursorPosition.line),
          change
        )
      | #backwards | #forwards ->
        set line = lineUtils.getNextLineOfChangeOfIndentation(
          change,
          direction,
          document,
          currentLine
        )

    if line is #some(line) ->
      selection = Selection(
        line.range.start
        line.range.start
      )
  }

def directionToDelta: Direction -> (number -> number)
  = { | #forwards  -> { + 1 }
      | #backwards -> { - 1 } }

export def iterLines
  : [TextDocument] IterationOptions -> Source(TextLine)
  = { options ->
    def advance = directionToDelta(options.direction)
    mut currentLineNumber = wordRangeToPosition(
      options.startingPosition
      options.direction
    ).line

    def withinBounds = {
      currentLineNumber >= 0 and
      (!options.bounds || currentLineNumber >= options.bounds.start.line) and
      (!options.bounds || currentLineNumber <= options.bounds.end.line) and
      currentLineNumber < lineCount  
    }

    seq {
      while withinBounds() ->
        def newLine = lineAt(currentLineNumber)

        yield newLine

        currentLineNumber = advance(currentLineNumber)
    } \skip(if options.currentInclusive -> 0 else -> 1)
  }


def getNearestLineOfChangeOfIndentation
  : [TextDocument] TextLine, common.Change -> TextLine
  = { currentLine, change ->
    def diff = changeToDiff(change)

    for iterLinesOutwards(currentLine.lineNumber) | backwardsLine, forwardsLine ->
      if forwardsLine and
        !forwardsLine.isEmptyOrWhitespace and
        diff(
          forwardsLine.firstNonWhitespaceCharacterIndex,
          currentLine.firstNonWhitespaceCharacterIndex
        ) ->
        return forwardsLine

      if backwardsLine and
        !backwardsLine.isEmptyOrWhitespace and
        diff(
          backwardsLine.firstNonWhitespaceCharacterIndex,
          currentLine.firstNonWhitespaceCharacterIndex
        ) ->
        return backwardsLine
  }


export def iterLinesOutwards
  : TextDocument, number -> Seq(LinePair)
  = { document, currentLineNumber ->
    mut forwardsPointer = currentLineNumber + 1
    mut backwardsPointer = currentLineNumber - 1  

    def forwardsPointerInBounds() ->
      forwardsPointer <= document.lineCount

    def backwardsPointerInBounds() ->
      backwardsPointer >= 0

    seq {
      while forwardsPointerInBounds() and backwardsPointerInBounds() ->
        def backwardsLine = 
          if backwardsPointerInBounds() -> document.lineAt(backwardsPointer)
          else #nil

        def forwardsLine =
          if forwardsPointerInBounds() -> document.lineAt(forwardsPointer)
          else #nil

        yield (backwardsLine, forwardsLine)

        set forwardsPointer++
        set backwardsPointer--
    }
  }

  
export def quickCommandPicker
  : (list(QuickCommand), (label: string, detail: string)?) -> Async(QuickCommand | string | #nil)
  = { commands, freeEntryOptions -> async { resolve, reject ->
      type QuickPickItem = QuickPickItem & (
        quickKey: common.Char?
        displayOnly: true?
      )

      def quickPick = window.createQuickPick(): QuickPickItem

      def freeEntryItems = list {
        if freeEntryOptions ->
          yield (
            label = ""
            kind = QuickPickItemKind.Separator
            displayOnly = true
          )
          yield (
            label = freeEntryOptions.label
            alwaysShow = true
            detail = freeEntryOptions.detail
            displayOnly = true
          )
      }

      set quickPick.items = commands
        \map { e ->
          ( quickKey = e.quickKey
            label = "[{e.quickKey}]"
            description = e.label
            execute = e.execute )
          }
        \concat(freeEntryItems)

      quickPick.onDidHide {
        resolve()
        quickPick.dispose()
      }

      quickPick.onDidChangeValue { s ->
        commands
        \tryFind { .quickKey == s } 
        \match
          | #some, option ->
            resolve(option)
            quickPick.dispose()
            return
          | #nil where !freeEntryOptions -> 
            set quickPick.value = ""
          | #nil ->
            #nil
      }

      quickPick.onDidAccept {
        def selected = quickPick.selectedItems(0)

        if selected.displayOnly ->
          if quickPick.value ->
            resolve(quickPick.value)
          else return
        
        commands 
          \tryFind { .quickKey == selected.quickKey } 
          \match
            | Some option ->
              resolve(option)
              quickPick.dispose()
              return
            | #nil -> 
              quickPick.dispose()
      }

      quickPick.show()
    }
  }